#platform "uVGA-III"
#inherit "4DGL_16bitColours.fnc"
#inherit "C_like_defines.fnc"
#include "Operational Parameters.fnc"
#include "Useful functions.fnc"
#include "MidyAX Defines.fnc"
#constant TRUE  1
#constant FALSE 0

#MODE RUNFLASH

//#define DEBUG2
//#define DEBUG3
//#define DEBUG4

#CONST      //Define the RX state machine states
    WAITING := 0x00,    // Waiting for new message to start.
    STARTED            // Processing message
#END
#CONST                      //Define misc Items (buffer sizes, etc)
    RX_BUF_SIZE := 256,     //Size of the receive buffer for serial port
    TX_BUF_SIZE := 1,      //Size of the transmit buffer for serial port
    RX_MSG_MAX_SIZE:= 401 // 1/2 the Max length if an incoming message, not including "wrapper" of $ or CR
    RX_MSG_MIN_SIZE := 2;
#END
//*************************************************************************************************************************
// ----------------------------------------------
//       Define any Global Variables here
// ----------------------------------------------
var tx_buf[TX_BUF_SIZE];                        //This is the TX buffer.  It will hold 2x TX_BUF_SIZE bytes
var rx_buf[RX_BUF_SIZE];                        //This is the RX buffer.  It will hold 2x RX_BUF_SIZE bytes

var DP; // pointer to disk struct



/////////////////
// Display Global Variables
var XX, YY, MAX_X, MAX_Y;
var lineColor;
var i, j, k, index;

// UNITs
var units[20];
var U0[UNIT_MAX_LENGTH], U1[UNIT_MAX_LENGTH], U2[UNIT_MAX_LENGTH], U3[UNIT_MAX_LENGTH], U4[UNIT_MAX_LENGTH], U5[UNIT_MAX_LENGTH];
var U6[UNIT_MAX_LENGTH], U7[UNIT_MAX_LENGTH], U8[UNIT_MAX_LENGTH], U9[UNIT_MAX_LENGTH], U10[UNIT_MAX_LENGTH], U11[UNIT_MAX_LENGTH];
var U12[UNIT_MAX_LENGTH], U13[UNIT_MAX_LENGTH], U14[UNIT_MAX_LENGTH], U15[UNIT_MAX_LENGTH], U16[UNIT_MAX_LENGTH], U17[UNIT_MAX_LENGTH], U18[UNIT_MAX_LENGTH], U19[UNIT_MAX_LENGTH];


////////////////
// Control Page Variables
var effectTypeLabel[LABEL_MAX_LENGTH];
var lab1[LABEL_MAX_LENGTH], lab2[LABEL_MAX_LENGTH], lab3[LABEL_MAX_LENGTH], lab4[LABEL_MAX_LENGTH], lab5[LABEL_MAX_LENGTH], lab6[LABEL_MAX_LENGTH], lab7[LABEL_MAX_LENGTH], lab8[LABEL_MAX_LENGTH], lab9[LABEL_MAX_LENGTH], lab10[LABEL_MAX_LENGTH];
var lab11[LABEL_MAX_LENGTH], lab12[LABEL_MAX_LENGTH], lab13[LABEL_MAX_LENGTH], lab14[LABEL_MAX_LENGTH], lab15[LABEL_MAX_LENGTH], lab16[LABEL_MAX_LENGTH], lab17[LABEL_MAX_LENGTH], lab18[LABEL_MAX_LENGTH], lab19[LABEL_MAX_LENGTH], lab20[LABEL_MAX_LENGTH];
var lab21[LABEL_MAX_LENGTH], lab22[LABEL_MAX_LENGTH], lab23[LABEL_MAX_LENGTH], lab24[LABEL_MAX_LENGTH], lab25[LABEL_MAX_LENGTH], lab26[LABEL_MAX_LENGTH], lab27[LABEL_MAX_LENGTH], lab28[LABEL_MAX_LENGTH], lab29[LABEL_MAX_LENGTH], lab30[LABEL_MAX_LENGTH];
var lab31[LABEL_MAX_LENGTH], lab32[LABEL_MAX_LENGTH], lab33[LABEL_MAX_LENGTH], lab34[LABEL_MAX_LENGTH], lab35[LABEL_MAX_LENGTH], lab36[LABEL_MAX_LENGTH], lab37[LABEL_MAX_LENGTH], lab38[LABEL_MAX_LENGTH], lab39[LABEL_MAX_LENGTH], lab40[LABEL_MAX_LENGTH];

var controlPage_Labels[BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER];
var controlPage_RawValues[BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER];
var controlPage_MIDIValues[BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER];
var controlPage_ID_ModValList[BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER];
var controlPage_Unit[BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER];


// MODAL LISTs
#define LBS 20
var lastLoadedModalList := -1, lastLoadedEffectParametersList := -1, lastNumbModal := -1, lastNumbParam := -1;
var tempoSTR[30];
var tempoSTR2 [50];
var FP2;

var modalLabelBuffer[181]; //Contains all the labels of a modal parameter
var paramLabelBuffer[111]; //Contains all the allowed Parameter Label of an Effect Type
var paramIDBuffer[111]; //Contains all the IDs of allowed parameters

var fileName[20];
var filePtr, res, FP1, p, p2, numberOf_ModVal, numberOf_Param, length, freeMem;
var startTime, elapsed;

// AXE-FX PRESET
var NumberOf_EffectBLocks_InPreset;
var OBState[40];
var XYState[40];
var EffectTypeID[40];
var EffectBlockID[40];
var PresetName[18];


// CURRENT CONTROL PAGE
var CurrentControlPage_EffectBlockID, CurrentControlPage_EffectTypeID, CurrentControlPage_OBState, CurrentControlPage_XYState, CurrentControlPage_SCENE;
var numberOfControlPages;
var ControlPages_EffectType_IDs[32];
var ControlPages_EffectType_Labels[32];
//var ETLab0[4], ETLab1[4], ETLab2[4], ETLab3[4], ETLab4[4], ETLab5[4], ETLab6[4], ETLab7[4], ETLab8[4], ETLab9[4];
//var ETLab10[4], ETLab11[4], ETLab12[4], ETLab13[4], ETLab14[4], ETLab15[4], ETLab16[4], ETLab17[4], ETLab18[4], ETLab19[4];
//var ETLab20[4], ETLab21[4], ETLab22[4], ETLab23[4], ETLab24[4], ETLab25[4], ETLab26[4], ETLab27[4], ETLab28[4], ETLab29[4];
//var ETLab30[4], ETLab31[4];
var ETLab[32];

//*************************************************************************************************************************
func InitComPort()
    var private count := 0;
    if ( count > 1 )
        to(TEXT);print("Com port init number = ", count, "\n");
    else
        to(TEXT);print("Started InitComPort ()");
    endif
    count++;

    while(serin1() >= 0);                   //Empty out any pending bytes at port
    repeat
        com_SetBaud(COM1,11520);              //Set baud rate to 9600
        com1_Init(rx_buf,RX_BUF_SIZE,0);     //Set the comms RX buffer //TODO : USE qulifier to avoif parasite messages
        nbPause(5);                         //Non-blocking pause for 5 ms to see if any com errors occur
    until (!com1_Error());                   //Keep retrying until no more errors
    com1_TXbuffer(tx_buf,sizeof(tx_buf)*2,0);
    main.rx_state := WAITING;       //Since we reset the com buffer, we should discard any messages we were building
endfunc


//*************************************************************************************************************************
func nbPause(var msec)
    sys_SetTimer(TIMER0, msec);          // pause for msec ms, non blocking
    while(peekW(TMR0));
endfunc


//*************************************************************************************************************************
func init_Drive()
    var retry := 10;
    if(!(DP := file_Mount()))
        while(retry--)
            if((DP := file_Mount())) break;
        wend
        if (retry) return "Mount Failed!";
    endif
    return "Disk mounted";
endfunc


func Load_ETLab()
    //txt_Width(1);
    //txt_Height(1);
    var labelPtr;
    // OPEN and READ MAP_ET.txt
    FP2 := file_Open("MAP_ET.txt", 'r');
    if( file_Error() > 0)
        to(TEXT);print("File MAP_ET.txt not found\n", "File ERROR = ", file_Error() );
        pause(5000);
        //continue;
    endif
    // Read number of values
    file_GetS(tempoSTR, 99, FP2);
    p := str_Ptr( tempoSTR );
    str_GetW( &p, &numberOfControlPages );
    for(k := 0; k < numberOfControlPages; k++)
        p := str_Ptr( tempoSTR2 );
        str_Copy(p, "");
        res := file_GetS(tempoSTR2, 99, FP2);
        str_GetW( &p, &( ControlPages_EffectType_IDs[k] ) );
        //to(TEXT); print("Line ",k, " read = ", [STR] tempoSTR2, "\n");
        p++; // To move pointer after the space char
        length := str_Length(p); // length of the remaining string which is the label
        //to(TEXT); print("Length till EoL ", k, " = ", length, "\n");
        ETLab[k] := mem_Alloc( length );
        if( ETLab[k] == 0 )
            to(TEXT); print("Memory ALLOC error for ETLab n°", k );  pause(5000);
        endif
        labelPtr := str_Ptr( ETLab[k] );
        str_CopyN(labelPtr, p, length);
        //to(TEXT); print("Value stored in ControlPages_EffectType_IDs[", k, "] = ",  ControlPages_EffectType_IDs[k], "\n");
        //to(TEXT); print("Value stored in ETLab[", k, "] = ", [STR] ETLab[k], "\n");
        if( file_Error() == FE_EOF && k < numberOfControlPages-1)
            to(TEXT); print("File MAP_ET.txt: EoF at k =", k, "\n", "File ERROR = ", file_Error() );  pause(5000);
            break;
        endif
    next
    res := file_Close(FP2);
    if( res == 0)
        to(TEXT); print("File MAP_ET.txt  not closed\n", "File ERROR = ", file_Error() );  pause(5000);
    endif
    //pause(30000);
    //txt_Width(3);
    //txt_Height(3);

/*    for(k := 0; k < numberOfControlPages - 1; k++)
        res := mem_Free( ETLab[k] );
        if ( res == 0  )
            gfx_MoveTo(0,60);
            to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" ); pause(2000);
        endif
    next*/


endfunc





//*************************************************************************************************************************
func main()
    var bytesatport;
    var LOGO; //File handle for LOGO file

    var private rx_state := WAITING;         //Holds the current message state. Retained between calls (because of private)
    var private msg_buf[RX_MSG_MAX_SIZE];   //Holds the Message ASCII data. Retained between calls
    var private msgIndex;                   //Holds message body index. Retained between calls
    var private msgPtr;                     //String pointer Retained between calls
    var perm_msgPtr;                        //Sting pointer to beginning of msg_buf
    var comByte;                            //Next byte to be processed from RX buffer
    var i;
    var msgvalue;


    *controlPage_Labels := [  lab1, lab2, lab3, lab4, lab5, lab6, lab7, lab8, lab9, lab10, lab11 , lab12 , lab13 , lab14 , lab15 , lab16 , lab17 , lab18 , lab19 , lab20 , lab21 , lab22 , lab23 , lab24 , lab25 , lab26 , lab27 , lab28 , lab29 , lab30 , lab31 , lab32 , lab33 , lab34 , lab35 , lab36 , lab37 , lab38 , lab39 , lab40 ];
    *units  := [ U0, U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19 ];
//    *ETLab := [ ETLab0, ETLab1, ETLab2, ETLab3, ETLab4, ETLab5, ETLab6, ETLab7, ETLab8, ETLab9, ETLab10, ETLab11, ETLab12, ETLab13, ETLab14, ETLab15, ETLab16, ETLab17, ETLab18, ETLab19, ETLab20, ETLab21, ETLab22, ETLab23, ETLab24, ETLab25, ETLab26, ETLab27, ETLab28, ETLab29, ETLab30, ETLab31];


    /*for (i := 0; i < BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER; i++)
        print("i=",i,", controlPage_Labels[",i,"]=",controlPage_Labels[i],", ");
        msgPtr :=  str_Ptr(controlPage_Labels[i]);
        print("i=",i,", msgPtr=",msgPtr,", ");str_Printf ( &msgPtr , "label = %s\n" );
    next
    pause(20000);*/

    // Initializes UNIT labels
    for (i := 0; i < 20; i++)
        p :=str_Ptr( units[i] );
        str_Copy( p, "");
    next

    // Init the com port.
    InitComPort();

    // Init the Display
    gfx_Set(SCREEN_RES,1);
    gfx_BGcolour(BLACK);
    //gfx_Cls();
    MAX_X := gfx_Get(X_MAX);
    MAX_Y := gfx_Get(Y_MAX);
    gfx_Set(PEN_SIZE, OUTLINE);
    lineColor := DARKRED;

    putstr( init_Drive() );

/*    // CHECK IF LOGO IS PRESENT ON THE SD CARD
    if(!file_Exists("LOGO_4.gci"))
        putstr("File ""LOGO_4.gci"" not found\n");  pause(2000);
    else
        LOGO := file_Open("LOGO_4.gci", 'r');
        file_Image(0,0, LOGO);
        file_Close(LOGO);
    endif
*/

   gfx_MoveTo(0,50);
   freeMem := mem_Heap();
   print("FreeMem = ", freeMem, "\n");


   var k;
   if(!file_Exists("Units.txt"))
        putstr("File ""Units.txt"" not found\n");  pause(2000);
   else
        LOGO := file_Open("Units.txt", 'r');
        file_GetS(tempoSTR, 99, LOGO);
        p := str_Ptr( tempoSTR );
        str_GetW( &p, &numberOf_ModVal );
        //to(TEXT); print("Number of units = ", numberOf_ModVal, "\n");
        for(k := 0; k < numberOf_ModVal; k++)
            str_Copy(p, "");
            res := file_GetS(tempoSTR, 99, LOGO);
            //to(TEXT); print(k, " value = ", [STR] tempoSTR, "\n");
            p := str_Ptr( tempoSTR );
            p2 := str_Ptr( units[k] );
            str_Copy(p2, "");
            str_Copy(p2, p);
        next
        file_Close(LOGO);
   endif


    // Check that all the files containing the Parameters Modal Lists are present on the SD card
    /*for(i := 0; i < AXEFX_NumOfModalList_DEFINE; i++)
        filePtr := str_Ptr(fileName);
        str_Copy(filePtr, "");
        to(fileName);
        print("ML_", i, ".txt\0");
        //to(TEXT);
        //print([STR]fileName, "\n");
        //print( "Length =", str_Length(filePtr), "\n");
        if(!file_Exists(filePtr))
            to(TEXT);print("File", [STR] fileName,"not found\n");  pause(500);
        endif
    next*/

    // LOAD THE EFFECT TYPE labels displayed in the CONTROL PAGE state bar
    Load_ETLab();


    // CHECK IF SUBPROGRAMS ARE PRESENT ON THE SD CARD
    /*var ok := 1;
    gfx_MoveTo(100,100);
    if(!file_Exists("COM_.4FN"))putstr("COMP.4FN not found\n"),ok := 0;
    if(!file_Exists("GRAPHEQ.4FN"))putstr("GRAPHEQ.4FN not found\n"),ok := 0;
    if(!file_Exists("PARAMEQ.4FN"))putstr("PAREQ.4FN not found\n"),ok := 0;
    if(!file_Exists("AMP.4FN"))putstr("AMP.4FN not found\n"),ok := 0;
    if(!ok)
        gfx_MoveTo(100,200); putstr("At least One file missing\n"); pause(2000); return;
    endif*/

    gfx_MoveTo(0,0);
    //putstr("Listening to the ARDUINO\n");

    perm_msgPtr := str_Ptr(msg_buf);
    // Listen to COM1
    repeat
        bytesatport:=com1_Count();
        if( bytesatport > 0 )
            while (bytesatport)
                //print("rx_state = ", rx_state, "\n");
                comByte := serin1();
                if (comByte < 0) continue;
                if (comByte == '$')
                    //putstr("$ received\n");
                    rx_state := STARTED;
                    msgIndex := 0;
                    msgPtr := perm_msgPtr;
                    //mem_Set(msg_buf,0,sizeof(msg_buf)*2);
                    continue;
                endif

                if( rx_state == STARTED )
                    if ( comByte == 13 )
                        //putstr("13 received\n");
                        if( rx_state == STARTED && msgIndex >= RX_MSG_MIN_SIZE )
                            str_PutByte(msgPtr,'\0');
                            //Process_Msg( &msg_buf[0], msgIndex );
                            Process_Msg( &msg_buf[0]);
                            rx_state := WAITING;
                            break;
                        else
                            rx_state := WAITING;
                        endif
                    else
                        if ( msgIndex > RX_MSG_MAX_SIZE )
                            rx_state := WAITING;
                        else
                            //print("BYTE = ", comByte, "\n");
                            str_PutByte(msgPtr++,comByte);
                            msgIndex++;
                        endif
                    endif
                endif
            wend
        else
            if( com1_Error() )
                InitComPort();
            endif
        endif
    forever

endfunc


//*************************************************************************************************************************
//func Process_Msg( var *msgBuf, var bufLength )
func Process_Msg( var *msgBuf )
    //var private A, B, C, D, Y, Z;
    //A:=-1; B:=-1; C:=-1; D:=-1; Y:=-1; Z:=-1;
    var private A:=-1, B:=-1, C:=-1, D:=-1 , Y:=-1, Z:=-1;
    var private ScreenShot_nb := 0;
    var msgPtr;
    var msgID;
    var msgvalue;
    var labelPtr;
    var i, j;

    #ifdef DEBUG
        //putstr("Start Process_Msg\n");
    #endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Processing received message
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    msgPtr := str_Ptr(msgBuf);

    // READ THE MESSAGE ID (A, B, C, ...)
    str_GetC(&msgPtr,&msgID);
    #ifdef DEBUG2
        print("Message ID = ", [CHR] msgID, "\n");
        str_Printf ( &msgPtr , "msgBuf = %s\n" );
        msgPtr := str_Ptr(msgBuf); msgPtr++;
    #endif


    switch( msgID )
        case 49 :   // 1111111111
            gfx_MoveTo(0,420);
            filePtr := str_Ptr(fileName);
            str_Copy(filePtr, "");
            to(fileName);
            print("SC_", ScreenShot_nb, ".gci\0");
            filePtr := str_Ptr(fileName);
            if( file_Exists( filePtr ) == 1) file_Erase( filePtr );
            FP2 := file_Open(filePtr, 'w'); // open a file to save the image
            if( file_Error() > 0)
                to(TEXT);print("Can't OPEN file", [STR] fileName, " for Screen Shot n° ", ScreenShot_nb, "\n", "File ERROR = ", file_Error(), "\n" );
                pause(1000);
                //continue;
            endif
            file_ScreenCapture(0,0,MAX_X,MAX_Y, FP2);// save an area
            file_Close(FP2);
            to(TEXT); print("Screen Shot n° ", ScreenShot_nb, " DONE\n");
            ScreenShot_nb++;
            return;
        break;

        case 50 :   // 222222222222
            to(TEXT); print( [STR] msgPtr,"\n");

            /*msgPtr++; // To move pointer after the space char
            length := str_Length(msgPtr); // length of the remaining string which is the label
            labelPtr := str_Ptr(PresetName);
            //copy_nstr(length, &msgPtr, labelPtr);
            str_CopyN(labelPtr, msgPtr, length);
            to(TEXT); print( [STR] labelPtr,"\n");*/
            return;
        break;


        case 65 :  // AAAAAAAAAAA
            str_GetW(&msgPtr,&msgvalue);
            //print("Received message A = ", msgvalue,"\n");
            A := msgvalue;
            //pause(300);
            B := -1;
            C := -1;

            if ( A == 1)
                var tempoVal;
                str_GetW(&msgPtr,&NumberOf_EffectBLocks_InPreset);
                //to(TEXT); print("NumberOf_EffectBLocks_InPreset =", NumberOf_EffectBLocks_InPreset, "\n"  );
                for (i := 0; i < NumberOf_EffectBLocks_InPreset; i++)
                     str_GetW(&msgPtr,&tempoVal);
                     if(tempoVal != i)
                        to(TEXT); print("Error in A message at i =", i, " received val = ", tempoVal, "\n"  ); pause(20000);
                     endif
                     str_GetW( &msgPtr, &( EffectBlockID[i] ) );
                     str_GetW( &msgPtr, &( EffectTypeID[i] ) );
                     str_GetW( &msgPtr, &( OBState[i] ) );
                     str_GetW( &msgPtr, &( XYState[i] ) );

                    //to(TEXT); print("EffectBlockID[i] = ", EffectBlockID[i], " "  );
                    //to(TEXT); print("EffectTypeID[i] = ", EffectTypeID[i], " "  );
                    //to(TEXT); print("OBState[i] = ", OBState[i], " "  );
                    //to(TEXT); print("XYState[i] = ", XYState[i], "\n"  );
                next
            endif
            //pause(20000);
            /*if ( A == 1)
                for (i := 0; i < BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER; i++)
                    controlPage_RawValues[i] := 999;
                    controlPage_MIDIValues[i] := 999;
                next
            endif*/
            msgPtr++; // To move pointer after the space char
            length := str_Length(msgPtr); // length of the remaining string which is the label
            labelPtr := str_Ptr(PresetName);
            //copy_nstr(length, &msgPtr, labelPtr);
            str_CopyN(labelPtr, msgPtr, length);

        break;

        case 66 :  // BBBBBBBBBB
            //str_GetW(&msgPtr,&msgvalue);

            // FREE the memory of the last loaded Modal List (of the previously selected Control Page)
            var k;
            if( lastNumbModal > 0)
                for( k := 0; k < lastNumbModal; k++)
                    res := mem_Free( modalLabelBuffer[k] );
                    if ( res == 0  )
                        gfx_MoveTo(0,60);
                        to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" );
                    else
                        //print("DE-ALLOCATED = ", res, "\n" );
                        //pause(1000);
                    endif
                next
            endif
            // Memory de-allocation of last loaded list of parameter labels
            if( lastNumbParam> 0)
                for( k := 0; k < lastNumbParam; k++)
                    res := mem_Free( modalLabelBuffer[k] );
                    if ( res == 0  )
                        gfx_MoveTo(0,60);
                        to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" );
                    else
                        //print("DE-ALLOCATED = ", res, "\n" );
                        //pause(100);
                    endif
                next
            endif

            lastLoadedModalList := -1; lastLoadedEffectParametersList := -1; lastNumbModal := -1, lastNumbParam := -1;

            str_GetW( &msgPtr, &( CurrentControlPage_EffectBlockID ) );
            str_GetW( &msgPtr, &( CurrentControlPage_EffectTypeID ) );
            str_GetW( &msgPtr, &( CurrentControlPage_OBState ) );
            str_GetW( &msgPtr, &( CurrentControlPage_XYState ) );
            str_GetW( &msgPtr, &( CurrentControlPage_SCENE ) );

            B := CurrentControlPage_EffectTypeID; // The number of the Effect Type
            C := -1;

            //to(TEXT); print("CurrentControlPage_EffectBlockID =", CurrentControlPage_EffectBlockID, "\n"  );
            //to(TEXT); print("CurrentControlPage_EffectTypeID =", CurrentControlPage_EffectTypeID, "\n"  );
            //to(TEXT); print("CurrentControlPage_OBState =", CurrentControlPage_OBState, "\n"  );
            //to(TEXT); print("CurrentControlPage_XYState =", CurrentControlPage_XYState, "\n"  );
            //to(TEXT); print("CurrentControlPage_SCENE =", CurrentControlPage_SCENE, "\n"  );

            msgPtr++; // To move pointer after the space char
            length := str_Length(msgPtr); // length of the remaining string which is the label
            labelPtr := str_Ptr(effectTypeLabel);
            //copy_nstr(length, &msgPtr, labelPtr);
            str_CopyN(labelPtr, msgPtr, length);

            #ifdef DEBUG2
                print("Received message B value = ", msgvalue,"\n");
                print("String length msgPtr = ", length,"\n");
                labelPtr := str_Ptr(effectTypeLabel);
                str_Printf ( &labelPtr , "labelPtr = %s\n" );
            #endif
            //pause(20000);

            // INITIALIZATION OF THE PARAMETER LABELS DISPLAY ON THE CURRENT CONTROL PAGE
            for (i := 0; i < BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER; i++)
                //print(i," = ,", controlPage_Labels[i], ";");
                *controlPage_Labels[i] := '\0';
                //print(i," = ,", controlPage_Labels[i], ";");
            next
        break;

        case 67 :  // CCCCCCCCCC
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // RECEPTION OF THE PARAMETER INFO FOR ONE CONTROL ELEMENT : Param Number, Param Label, Param Unit, Modal List of the param
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            var controlNumber, effectType, paramNumber;
            var label[LABEL_MAX_LENGTH];
            var label1[LABEL_MAX_LENGTH];
            var label1Ptr;

            // READ the message
            str_GetW( &msgPtr, &controlNumber );
            str_GetW( &msgPtr, &effectType );
            str_GetW( &msgPtr, &paramNumber );
            str_GetW( &msgPtr, &(controlPage_Unit[controlNumber]) );
                // CHECK UNITS EXIST
                if( controlPage_Unit[controlNumber] < 0 || controlPage_Unit[controlNumber] > 7 )
                    controlPage_Unit[controlNumber] := 0;
                endif
            str_GetW( &msgPtr, &(controlPage_ID_ModValList[controlNumber]) );

#ifdef DEBUG2
            gfx_Cls();
            gfx_MoveTo(0,0);
            print("ControlNumber = ", controlNumber,"  ");
            print("Received message C, for Effect Type = ", effectType,"\n");
            print("paramNumber = ", paramNumber,"\n");
            print("controlPage_ID_ModValList[controlNumber] = ", controlPage_ID_ModValList[controlNumber],"\n");
            print("controlPage_Unit[controlNumber] = ", controlPage_Unit[controlNumber],"\n");
            //pause(2000);
#endif

            labelPtr := str_Ptr(label);
            msgPtr++;
            length := str_Length(msgPtr);
            copy_nstr(length, &msgPtr, labelPtr);
            labelPtr := str_Ptr(label);

            if ( controlNumber <= BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER)
                labelPtr := str_Ptr(label);
                length := str_Length(labelPtr);
                msgPtr :=  str_Ptr(controlPage_Labels[controlNumber]);
                copy_nstr(length, &labelPtr, msgPtr);
                msgPtr :=  str_Ptr(controlPage_Labels[controlNumber]);
                    #ifdef DEBUG2
                        print("String length msgPtr= ", length,"\n");
                        //print("labelPtr = ");
                        print("controlPage_Labels[controlNumber] = ", [STR] controlPage_Labels[controlNumber], "\n");
                        pause(2000);
                    #endif
            endif

            if (controlNumber == BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER + 1)
                 C := effectType;
                    #ifdef DEBUG2
                        print("message C 41 received, Effect type = ", effectType, "\n");
                        pause(2000);
                    #endif
            else
                return;
            endif
        break;

        case 68 :  // DDDDDDDDD
            str_GetW(&msgPtr,&controlNumber);
            //#ifdef DEBUG2
                //print("ControlNumber = ", controlNumber, "  ");
            //#endif
            if(controlNumber != BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER + 1)
                //controlPage_MIDIValues[controlNumber] := 0;
                //controlPage_RawValues[controlNumber] := 0;
                str_GetW(&msgPtr,&controlPage_MIDIValues[controlNumber]);
                str_GetD(&msgPtr,&controlPage_RawValues[controlNumber]);
                //to(TEXT); print("controlNumber = ", controlNumber, "  controlPage_RawValues[controlNumber] = ", controlPage_RawValues[controlNumber], "\n");
                //print("controlPage_MIDIValues[controlNumber] = ", controlPage_MIDIValues[controlNumber], "\n");
            endif
            if (controlNumber == BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER + 1)
                 D := BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER + 1;
            else
                return;
            endif
        break;
        case 89 :  // YYYYYYYYY
            str_GetW(&msgPtr,&controlNumber);
            str_GetW(&msgPtr,&controlPage_MIDIValues[controlNumber]);
            //print("ControlNumber = ", controlNumber, "\n");
            //print("controlPage_MIDIValues[controlNumber] = ", controlPage_MIDIValues[controlNumber], "\n");
            //to(TEXT); print("controlNumber = ", controlNumber, "  controlPage_RawValues[controlNumber] = ", controlPage_RawValues[controlNumber], "\n");
            //return;
            Y := controlNumber;
        break;
        case 90 :  // ZZZZZZZZZ
            str_GetW(&msgPtr,&controlNumber);
            str_GetW(&msgPtr,&controlPage_MIDIValues[controlNumber]);
            str_GetD(&msgPtr,&controlPage_RawValues[controlNumber]);
            //print("ControlNumber = ", controlNumber, "\n");
            //print("controlPage_MIDIValues[controlNumber] = ", controlPage_MIDIValues[controlNumber], "\n");
            //to(TEXT); print("controlNumber = ", controlNumber, "  controlPage_RawValues[controlNumber] = ", controlPage_RawValues[controlNumber], "\n");
            //return;
            Z := controlNumber;
        break;
    endswitch

    txt_Set(TEXT_COLOUR, WHITE);
    txt_BGcolour(BLACK);

    ///////////////////////////////////////////////////////////////////////////
    // According to the STATE calls the right functions
    ///////////////////////////////////////////////////////////////////////////
    // Param A determines the mode (or main screen)

    switch ( A )
        case 0 :
            // INIT SCREEN
            gfx_MoveTo(10,10);
            print("INIT SCREEN\n");pause(100);
            return;
        break;
        case 1 :
            // CONTROL PAGE SCREEN
            if( B == C && B!= -1 && C!=-1 && D == BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER + 1)
                //pause(5000);
                screen_Display_ControlPage( );
                B := -1;
                C := -1;
                D := -1;
                return;
            endif
            if( B == -1 && C == -1 && D == -1 && Z != -1)
                //gfx_MoveTo(0,0); print("Calling Z display \n");pause(2000);
                //print("B = ", B, " C = ", C, " D = ", D, " Z = ", Z,"\n");
                //screen_Display_ControlPage( Z );
                display_ParamValue( Z );
                Z := -1;
            endif
            if( B == -1 && C == -1 && D == -1 && Y != -1)
                //gfx_MoveTo(0,0); print("Calling Z display \n");pause(2000);
                //print("B = ", B, " C = ", C, " D = ", D, " Z = ", Z,"\n");
                //screen_Display_ControlPage( Z );
                display_ParamLabel( Y );
                Y := -1;
            endif        break;
        case 99 :
            // OPERATIONAL PARAMETERS SCREEN
            gfx_MoveTo(10,10);
            print("Operationam Parameters SCREEN\n");pause(100);
            return;
        break;
    endswitch

endfunc

//*************************************************************************************************************************
//*************************************************************************************************************************
func screen_Display_ControlPage( )
    //////////////////////////////////////////////////
    ///////// Draw the ControlPage screen
    //////////////////////////////////////////////////
    var start_X, start_Y, controlDisplayHeight;
    var displayStr[20], tempoChar;
    var strNum;
    var labPtr, labStr1Ptr, labStr2Ptr, labStr3Ptr, curPtr;
    var labStr1[10], labStr2[10], labStr3[10];
    var labLength, str1Length, str2Length, str3Length, curLength;
    var res;

    //init_Drive();

    gfx_Cls();


    //gfx_MoveTo(0,0);
    //print("Control page for Effect Type = ", controlPageNumber,"\n");
    //print("Control Page Screen\n");

    // If the Effect Block list is displayed
    controlDisplayHeight := MAX_Y;
    if( OP_EffectBlock_Display == 1)
         controlDisplayHeight := MAX_Y * 5/6;
    else
        if( OP_EffectBlock_Display == 2)
            controlDisplayHeight := MAX_Y * 4/6;
        endif
    endif

    txt_FontID (FONT1);
    txt_Width(2);
    txt_Height(2);
    txt_Bold(ON);
    txt_FGcolour(YELLOW);
    txt_BGcolour(DARKRED);

    gfx_RectangleFilled( 0, 0, MAX_X, (MAX_Y+1) / 24 , DARKRED);

    to(TEXT);
    print("PRESET: ", [STR] PresetName);
    //print("BlockID =", CurrentControlPage_EffectBlockID  );
    //print(" TypeID =", CurrentControlPage_EffectTypeID  );

    gfx_MoveTo( (MAX_X+1) /8 *5, 0);
    if( CurrentControlPage_OBState == 0)
        print("OFF");
    else
         print("ON");
    endif
    if( CurrentControlPage_XYState == 0)
        print(" Y");
    else
         print(" X");
    endif
    print(" SCENE ", CurrentControlPage_SCENE  );



    // Draw vetical lines
    start_X := (MAX_X+1) /8;
    start_Y := (MAX_Y+1) /24;
    //start_Y := MAX_Y/12;
    for(i := 0; i < 9; i++)
        XX := ( MAX_X * i ) / 8;
        //gfx_Line( X-1, start_Y, X-1,  MAX_Y, lineColor);
        gfx_Line( XX, start_Y, XX,  MAX_Y, lineColor);
        //gfx_Line( X+1, start_Y, X+1,  MAX_Y, lineColor);
    next

    // Horizontal lines and display labels
//    start_Y := (MAX_Y+1)/12 + (MAX_Y+1) /24;
//    gfx_Line(0, start_Y ,MAX_X, start_Y, lineColor );
//    gfx_Line(0, start_Y + (MAX_Y+1)/12 ,MAX_X, start_Y + (MAX_Y+1)/12, lineColor );


    txt_FGcolour(GRAY);
    txt_Bold(OFF);


    XX := ( MAX_X +1) / 8;
    //to(TEXT); print("MAX_X = ", MAX_X," MAX_X/8 = ", MAX_X/8, "\n");
    //to(TEXT); print("MAX_Y = ", MAX_Y," MAX_Y/12 = ", MAX_Y/12, "\n");  pause(10000);
    index :=0;
    for(i := 1; i <= 2; i++)
        YY := ( (MAX_Y+1) / 12) * (i-1) + ((MAX_Y+1) / 24);
        gfx_Line( 0, YY, MAX_X,  YY, lineColor);
        for(j := 1; j <= 8; j++)
            txt_Width(1);
            txt_Height(2);
            txt_FontID (FONT1);
            if( ControlPages_EffectType_IDs[index] -2 == CurrentControlPage_EffectTypeID )
                txt_Bold(ON);
                txt_FGcolour(YELLOW);
                txt_BGcolour(RED);
                if( CurrentControlPage_OBState == 1)
                    txt_BGcolour(RED);
                    gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24)  ,   (XX*j) -1   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , XX*(j-1) , ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24), RED);
                endif
            else
                txt_FGcolour(GRAY);
                txt_BGcolour(BLACK);
                txt_Bold(OFF);
                for( k:=0; k < NumberOf_EffectBLocks_InPreset; k++)
                    if( EffectTypeID[k] == ControlPages_EffectType_IDs[index] -2)
                        txt_FGcolour(WHITE);
                        txt_Bold(ON);
                        if( OBState[k] == 1)
                            txt_FGcolour(BLACK);
                            txt_BGcolour(WHITE);
                            gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24)  ,   (XX*j)-1   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , XX*(j-1)  , ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24), WHITE);
                        endif
                        break;
                    endif
                next
            endif
            gfx_MoveTo( XX * (j-1) + 2, YY + MAX_Y/64 );
            putstr( ETLab[index] );


            if( ControlPages_EffectType_IDs [index+16 ] -2 == CurrentControlPage_EffectTypeID )
                txt_Bold(ON);
                txt_FGcolour(YELLOW);
                txt_BGcolour(RED);
                if( CurrentControlPage_OBState == 1)
                    txt_BGcolour(RED);
                    gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24) ,   (XX*j)-2  ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , (XX*j)-2 , ((MAX_Y+1)/12)* i -2 + ((MAX_Y+1) / 24), RED);
                endif
            else
                txt_BGcolour(BLACK);
                txt_FGcolour(GRAY);
                txt_Bold(OFF);
                for (k :=0; k < NumberOf_EffectBLocks_InPreset; k++)
                    if ( EffectTypeID[k] == ControlPages_EffectType_IDs [index+16] -2)
                        txt_FGcolour(WHITE);
                        txt_Bold(ON);
                        if( OBState[k] == 1)
                            txt_FGcolour(BLACK);
                            txt_BGcolour(WHITE);
                            gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24) ,   (XX*j)-2   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , (XX*j)-2 , ((MAX_Y+1)/12)*i -2 + ((MAX_Y+1) / 24), WHITE);
                        endif
                        break;
                    endif
                next
            endif
            gfx_MoveTo( XX * (j-1) + MAX_X/12, YY + MAX_Y/24 + 2 );
            putstr( ETLab[index+16] );

            gfx_Line(   XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24) ,   XX*j   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , lineColor );
            index++;
        next
    next


/*    labPtr :=  str_Ptr(effectTypeLabel);
    gfx_MoveTo( MAX_X/2 -40, MAX_Y/24 );
    txt_FGcolour(YELLOW);
    str_Printf( &labPtr , "%s\n" );*/


#ifdef DEBUG4
                gfx_MoveTo(0,420);
                freeMem := mem_Heap();
                to(TEXT); print("FreeMem = ", freeMem, "\n");
                //print("index = ", index, "  ID_ModValList = ", [DEC] controlPage_ID_ModValList[index],"\n");
#endif

    start_Y := (MAX_Y+1) /6 + ((MAX_Y+1) / 24);
    index :=0;
    for(i := 1; i < 6; i++)
        YY := ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24);
            gfx_Line( 0, YY, MAX_X,  YY, lineColor);
        for(j := 1; j <= 8; j++)
            //labPtr :=  str_Ptr(controlPage_Labels[index]);
            //str_Printf( &labPtr , "%s\n" );

            labPtr :=  str_Ptr(controlPage_Labels[index]);
            labLength := str_Length(labPtr);

            // IF THERE is no LABEL there is no PARAMETER displayed
            if( labLength > 0 )
                labStr1Ptr := str_Ptr(labStr1); labStr2Ptr := str_Ptr(labStr2); labStr3Ptr := str_Ptr(labStr3);
                str_PutByte(labStr1Ptr, '\0'); str_PutByte(labStr2Ptr, '\0'); str_PutByte(labStr3Ptr, '\0');
                curPtr := labStr1Ptr;
                strNum := 0;
                curLength :=0; str1Length := 0; str2Length := 0; str3Length := 0;

                //gfx_MoveTo(0,0);
                //print( "labLength = ", labLength, "\n" );
                //print( "controlNumber = ", controlNumber, "\n" );

                gfx_MoveTo( XX * (j-1) + 3, YY + 2 ); // + MAX_Y/128
                txt_Width(1);
                txt_Height(1);
                txt_FGcolour(WHITE);
                txt_BGcolour(lineColor);
                txt_FontID (FONT1);
                txt_Bold(OFF);
                print( " ", index + 1 , " ");
                txt_Bold(OFF);
                txt_FGcolour(RED);
                txt_BGcolour(BLACK);
                txt_FontID (FONT1);

                gfx_MoveTo( XX * (j-1) + MAX_X/64, YY + MAX_Y/24 );
                txt_Width(1);
                txt_Height(1);
                for(k := 0; k < labLength; k++)
                    str_GetC(&labPtr, &tempoChar);
                    if(  tempoChar == 32)
                        str_PutByte(curPtr, '\0');
                        if( strNum == 0 )
                            str1Length := curLength; curLength := 0;
                            curPtr := labStr2Ptr; strNum := 1;
                        else
                            if( strNum == 1 )
                                str2Length := curLength; curLength := 0;
                                curPtr := labStr3Ptr; strNum := 2;
                            endif
                        endif
                    else
                        str_PutByte( curPtr++  ,tempoChar);
                        curLength++;
                    endif
                next
                if( strNum == 0 ) str1Length := curLength;
                if( strNum == 1 ) str2Length := curLength;
                if( strNum == 2 ) str3Length := curLength;
                str_PutByte(curPtr, '\0');

                //str_Printf( &labStr1Ptr , "%s\n" ); str_Printf( &labStr2Ptr , "%s\n" ); str_Printf( &labStr3Ptr , "%s" );


                labStr1Ptr := str_Ptr(labStr1);
                labStr2Ptr := str_Ptr(labStr2);
                labStr3Ptr := str_Ptr(labStr3);

                //print( "   str1Length = ", str1Length, "\nstr2Length = ", str2Length, "\nstr3Length = ", str3Length);
                //pause(5000);


                txt_Bold(ON);
                if( str1Length + str2Length <= 9)
                    if( str1Length > 0 ) str_Printf( &labStr1Ptr  , "%s" );
                    if( str2Length > 0 ) str_Printf( &labStr2Ptr  , " %s" );
                    gfx_MoveTo( XX * (j-1) + MAX_X/64, YY + MAX_Y/24 + 12 );
                    if( str3Length > 0 ) str_Printf( &labStr3Ptr  , "%s" );
                else
                    if( str1Length > 0 ) str_Printf( &labStr1Ptr  , "%s" );
                    gfx_MoveTo( XX * (j-1) + MAX_X/64, YY + MAX_Y/24 + 12 );
                    if( str2Length > 0 ) str_Printf( &labStr2Ptr  , "%s" );
                    if( str3Length > 0 ) str_Printf( &labStr3Ptr  , " %s" );
                endif
                txt_Bold(OFF);
            endif

            if( labLength > 0 )

                display_ParamValue( index );

/*                gfx_RectangleFilled( X * (j-1) + MAX_X/ 11,
                                    Y + MAX_Y/9 + 18,
                                    X * (j-1) + MAX_X/11 + 20,
                                    Y + MAX_Y/9 + 25,
                                    BLACK);
*/
                txt_Width(1);
                txt_Height(1);
                gfx_MoveTo( XX * (j-1) + MAX_X/11, YY + MAX_Y/9 + 18 );
                //print( controlPage_MIDIValues[index] );
                //print( controlPage_Unit[index] , "\n");
                if( controlPage_Unit[index] != 0) // && index !=1)
                    putstr( units[ controlPage_Unit[index] ] );
                endif
            endif



            // IF labLength = 0 --> Nothing to display
            index ++;
        next
    next
    gfx_MoveTo(10,10);

    // TEST Image Capture --> Writing a slow
    /*var hFile, t;
    //sys_SetTimer(TIMER0, 20000);
    t := sys_T();
    hFile := file_Open("test.img", 'a'); // open a file to save the image
    file_ScreenCapture(20,20,300,300, hFile);// save an area
    file_ScreenCapture(0,0,200,200, hFile); // (save another area)
    file_Close(hFile); // now close the file
    t := sys_T() -t; //sys_GetTimer(TIMER0);
    gfx_MoveTo(0,0);
    print("time taken = ", t);

    hFile := file_Open("test.img", 'r'); // open the saved file
    file_Image(100, 100, hFile); // display the image
    file_Image(150, 180, hFile); // (display the next image)
    file_Close(hFile);*/

    return;
endfunc




func display_ParamValue( var controlNumber )
    var labPtr, labLength;

    //Display a parameter value at the right location on the screen
    index := controlNumber;
    i := controlNumber/8;
    j := controlNumber - ( i * 8 );
    i := i + 1;
    j := j + 1;
    XX := (MAX_X +1) / 8;
    YY :=  ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24);

    labPtr :=  str_Ptr(controlPage_Labels[index]);
    labLength := str_Length(labPtr);
    // IF THERE is no LABEL there is no PARAMETER displayed
    if( labLength == 0 ) return;


    if( controlPage_ID_ModValList[index] == -1 || controlPage_ID_ModValList[index] == -256) //TODO : Check why -256 ?????????
        //print("Real Value");

        gfx_RectangleFilled( XX * (j-1) + MAX_X/32 ,
                            YY + MAX_Y/10,
                            XX * (j-1) + MAX_X/32 + 34,
                            YY + MAX_Y/10 + 14,
                            BLACK);
        gfx_MoveTo( XX * (j-1) + MAX_X/32, YY + MAX_Y/10  );

        txt_FGcolour(LIGHTBLUE);
        txt_Width(1);
        txt_Height(2);
        print( controlPage_RawValues[index] );
    else
        if( lastLoadedModalList != controlPage_ID_ModValList[index] )

            if( lastNumbModal > 0)
                for(k := lastNumbModal -1; k >= 0 ; k--)
                    res := mem_Free( modalLabelBuffer[k] );
                    if ( res == 0  )
                        gfx_MoveTo(0,60);
                        to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" );
                    else
                        //print("DE-ALLOCATED = ", res, "\n" );
                        //pause(100);
                    endif
                next
            endif

#ifdef DEBUG2
            startTime := sys_T();
            gfx_MoveTo(0,10);
            print("LOADING  = ", sys_T(), "\n");
            gfx_MoveTo(0,20);
            print( "lastLoadedModalList = ", lastLoadedModalList, "\n" );
            gfx_MoveTo(0,30);
            print( "controlPage_ID_ModValList[index] = ", controlPage_ID_ModValList[index], "\n" );
            gfx_MoveTo(0,40);
            print( "lastNumbModal = ", lastNumbModal, "\n" );
            pause(10000);
#endif
            filePtr := str_Ptr(fileName);
            str_Copy(filePtr, "");
            to(fileName); print("ML_", controlPage_ID_ModValList[index], ".txt\0");

        //to(TEXT);
        //print([STR]fileName, "\n");
        //print( "Length =", str_Length(filePtr), "\n");

            FP2 := file_Open(filePtr, 'r');
            if( file_Error() > 0)
                to(TEXT);print("File ", [STR]fileName,"  not found\n", "File ERROR = ", file_Error() );
                pause(500);
                //continue;
            endif

            p := str_Ptr(tempoSTR);
            str_Copy( p, "");
            // Read number of values
            file_GetS(tempoSTR, 99, FP2);
            p := str_Ptr( tempoSTR );
            str_GetW( &p, &numberOf_ModVal );
            //to(TEXT); print("FILENAME = ", [STR] fileName, " numberOf_ModVal = ", numberOf_ModVal, "\n");
            //print("controlPage_RawValues[index] = ", controlPage_RawValues[index], "\n");
            //pause(10000);

           // TEMPORARY REMOVED
            /*
            if( controlPage_RawValues[index] < 0 || controlPage_RawValues[index] >= numberOf_ModVal )
                to(TEXT);print("ERROR item > numberOf_ModVal ", controlPage_RawValues[index], numberOf_ModVal);
                pause(5000);
               // continue;
            endif
            */

//to(TEXT); print("numberOf_ModVal ", numberOf_ModVal, "\n");
            for(k := 0; k < numberOf_ModVal; k++)
                p := str_Ptr( tempoSTR2 );
                str_Copy(p, "");
                res := file_GetS(tempoSTR2, 99, FP2);
//to(TEXT); print("Line ",k, " read = ", [STR] tempoSTR2, "\n");
                length := str_Length( p );
//to(TEXT); print("Length of line ", k, " = ", length, "\n");
                modalLabelBuffer[k] := mem_Alloc( length +1 );
                if( modalLabelBuffer[k] == 0 )
                     to(TEXT); print(" Memory ALLOC error for label n° ", k );  pause(500);
                endif
                p := str_Ptr( tempoSTR2 );
                p2 := str_Ptr( modalLabelBuffer[k] );
                str_Copy(p2, "");
                str_Copy(p2, p);
                //to(TEXT); print("Value stored in label[", k, "] = ", [STR] modalLabelBuffer[k], "\n");
                //pause(1000);
                if( file_Error() == FE_EOF )
                    to(TEXT); print("File", [STR]fileName,"  not closed\n", "File ERROR = ", file_Error() );  pause(500);
                    break;
                endif
            next

//gfx_MoveTo(0,50);
//freeMem := mem_Heap();
//print("FreeMem = ", freeMem, "\n");
//pause(2000);

            res := file_Close(FP2);
            if( res == 0)
                to(TEXT); print("File", [STR]fileName,"  not closed\n", "File ERROR = ", file_Error() );  pause(500);
            endif
            lastLoadedModalList := controlPage_ID_ModValList[index];
            lastNumbModal := numberOf_ModVal;
#ifdef DEBUG2
            to(TEXT);
            gfx_MoveTo(0,50);
            print( "lastLoadedModalList = ", lastLoadedModalList, "\n" );
            gfx_MoveTo(0,60);
            print( "lastNumbModal = ", lastNumbModal, "\n" );
#endif
        endif

        //print( [STR] modalLabelBuffer[ controlPage_RawValues[index] ]);

        if( i == 5)
            YY := ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24) -5;
        endif

        gfx_RectangleFilled( XX * (j-1) + MAX_X/ 92,
                            YY + MAX_Y/10 ,
                            XX * (j-1) + MAX_X/9 + 5,
                            YY + MAX_Y/10 + 15,
                            BLACK);

        gfx_MoveTo( XX * (j-1) + MAX_X/92, YY + MAX_Y/10  );
        txt_Width(1);
        txt_Height(2);
        txt_FGcolour(WHITE);

        // Pour les boutons 127 corrspond à 1 (dans une liste)
        if ( index > 31 && index < 40 && controlPage_RawValues[index] > 0)
            controlPage_RawValues[index] := 1;
        endif

        to(TEXT); print( [STR] modalLabelBuffer[ controlPage_RawValues[index] ] );

        //txt_Height(1);
        //print("\n controlPage_RawValues[index] = ", controlPage_RawValues[index], "  index = ", index );

        //elapsed := sys_T() - startTime;
        //to(TEXT);
        //print(elapsed);
        //putstr("\n");
    endif
    return;
endfunc





func display_ParamLabel( var controlNumber )
    var labPtr, labLength;
    ///////////////////////////////////////////////////////////////////////////////////////////
    // IN CUSTOMIZATION MODE, display a PARAMETER LABEL at the right location on the screen
    ///////////////////////////////////////////////////////////////////////////////////////////

    index := controlNumber;
    i := controlNumber/8;
    j := controlNumber - ( i * 8 );
    i := i + 1;
    j := j + 1;
    XX := (MAX_X +1) / 8;
    YY :=  ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24);

       //////////////////////////////////////////////////////////////////////////
       // Load list of Param Label if it is not allready loaded
       // Clear buffer memory if needed
       // Load Param Labels file "ET%.txt"
       //////////////////////////////////////////////////////////////////////////
       if( lastLoadedEffectParametersList != CurrentControlPage_EffectTypeID )

            // Memory de-allocation of previous list of parameter labels
            if( lastNumbParam> 0)
                for(k := lastNumbParam -1; k >= 0 ; k--)
                    res := mem_Free( paramLabelBuffer[k] );
                    if ( res == 0  )
                        gfx_MoveTo(0,60);
                        to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" );
                    else
                        //print("DE-ALLOCATED = ", res, "\n" );
                        //pause(100);
                    endif
                next
            endif

#ifdef DEBUG2
            startTime := sys_T();
            gfx_MoveTo(0,10);
            print("LOADING  = ", sys_T(), "\n");
            gfx_MoveTo(0,20);
            print( "lastLoadedEffectParametersList = ", lastLoadedEffectParametersList, "\n" );
            gfx_MoveTo(0,30);
            print( "CurrentControlPage_EffectTypeID = ", CurrentControlPage_EffectTypeID, "\n" );
            gfx_MoveTo(0,40);
            print( "lastNumbParam = ", lastNumbParam, "\n" );
            pause(10000);
#endif

            // BUILD THE FILE NAME
            filePtr := str_Ptr(fileName);
            str_Copy(filePtr, "");
            to(fileName); print("ET", CurrentControlPage_EffectTypeID + 2, ".txt\0");
    //gfx_MoveTo(0,10);
    //to(TEXT);print("FileName ", [STR]fileName,"\n");
            // OPEN THE PARAMETER LABELS FILE
            FP2 := file_Open(filePtr, 'r');
            if( file_Error() > 0)
                to(TEXT);print("File ", [STR]fileName,"  not found\n", "File ERROR = ", file_Error() );
                pause(500);
                //continue;
            endif

            // READ THE NUMBER OF RECORDS
            p := str_Ptr(tempoSTR);
            str_Copy( p, "");
            file_GetS(tempoSTR, 99, FP2);
    //to(TEXT);print("Raw Line read ", [STR]tempoSTR,"\n");
            p := str_Ptr( tempoSTR );
            str_GetW( &p, &numberOf_Param );

            // READ ALL THE RECORD

   //gfx_MoveTo(0,50);
   //to(TEXT); print("numberOf_Param ", numberOf_Param, "\n");

            for(k := 0; k < numberOf_Param; k++)
   //gfx_MoveTo(0,60);
                p := str_Ptr( tempoSTR2 );
                str_Copy(p, "");
                //Read a full line of the file into the res buffer
                res := file_GetS(tempoSTR2, 99, FP2);
                //Read the Parameter ID
                str_GetW(&p,&paramIDBuffer[k]);
  //to(TEXT); print("Line ",k, " read = ", [STR] tempoSTR2, "\n");
  //to(TEXT); print("&paramIDBuffer[",k, "] = ", paramIDBuffer[k], "\n");
                length := str_Length( p );
  //to(TEXT); print("Length of line ", k, " = ", length, "\n");
                paramLabelBuffer[k] := mem_Alloc( length +1 );
                if( paramLabelBuffer[k] == 0 )
                     to(TEXT); print(" Memory ALLOC error for label n° ", k );  pause(500);
                endif
                //
                p := str_Ptr( p );
                p2 := str_Ptr( paramLabelBuffer[k] );
                str_Copy(p2, "");
                str_Copy(p2, p);
 //to(TEXT); print("Value stored in paramLabel[", k, "] = ", [STR] paramLabelBuffer[k], "\n");
 //pause(500);
                if( file_Error() == FE_EOF )
                    to(TEXT); print("File", [STR]fileName,"  not closed\n", "File ERROR = ", file_Error() );  pause(500);
                    break;
                endif
            next

#ifdef DEBUG2
            gfx_MoveTo(0,50);
            freeMem := mem_Heap();
            print("FreeMem = ", freeMem, "\n");
            pause(2000);
#endif
            // CLOSE THE FILE
            res := file_Close(FP2);
            if( res == 0)
                to(TEXT); print("File", [STR]fileName,"  not closed\n", "File ERROR = ", file_Error() );  pause(500);
            endif

            // KEEP TRACK OF THE LAST EFFECT PARAMETER LIST THAT WAS LOADED
            lastLoadedEffectParametersList := CurrentControlPage_EffectTypeID;
            lastNumbParam := numberOf_Param;

#ifdef DEBUG2
            to(TEXT);
            gfx_MoveTo(0,50);
            print( "lastLoadedEffectParametersList = ", lastLoadedEffectParametersList, "\n" );
            gfx_MoveTo(0,60);
            print( "lastNumbParam = ", lastNumbParam, "\n" );
#endif

        endif

        //print( [STR] paramLabelBuffer[ controlPage_RawValues[index] ]);

        // CALCULATE THE DISPLAY LOCATION
        if( i == 5)
            YY := ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24) -5;
        endif

        gfx_RectangleFilled( XX * (j-1) + MAX_X/ 92,
                            YY + MAX_Y/10 ,
                            XX * (j-1) + MAX_X/9 + 5,
                            YY + MAX_Y/10 + 15,
                            BLACK);

        gfx_MoveTo( XX * (j-1) + MAX_X/92, YY + MAX_Y/10  );
        txt_Width(1);
        txt_Height(2);
        txt_FGcolour(WHITE);

   //gfx_MoveTo(0,0);

        //DISPLAY THE LABEL OF THE PARAMETER IN THE RIGHT LOCATION ON THE SCREEN
        for(k := 0; k < lastNumbParam; k++)
   //to(TEXT); print("k = ", k, " paramLabelBuffer", [STR] paramLabelBuffer[k], "\n");
            if( paramIDBuffer[k] == controlPage_MIDIValues[controlNumber] )
                p := str_Ptr( paramLabelBuffer[k]  );
                p2 := str_Ptr( controlPage_Labels[index]  );
                str_Copy(p2, "");
                str_Copy(p2, p);
   //to(TEXT); print("k = ", k, " index = ", index, " paramLabelBuffer", [STR] paramLabelBuffer[k], " controlPage_Labels", [STR] controlPage_Labels[index], "\n");
                break;
            endif
        next

//txt_Bold(OFF);
//txt_FGcolour(RED);
//txt_BGcolour(BLACK);
//txt_FontID (FONT1);

        //to(TEXT); print( [STR] paramLabelBuffer[ controlPage_RawValues[index] ] );
        to(TEXT); print( [STR] controlPage_Labels[ index ] );

        //txt_Height(1);
        //print("\n controlPage_RawValues[index] = ", controlPage_RawValues[index], "  index = ", index );

        //elapsed := sys_T() - startTime;
        //to(TEXT);
        //print(elapsed);
        //putstr("\n");
    //endif

    return;
endfunc


