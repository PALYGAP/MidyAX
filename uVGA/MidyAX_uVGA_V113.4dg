#platform "uVGA-III"
//////////////////////////////////////////////////////////////////////////////////////////////////
// PROGRAM:     MidyAX - BCR2000 to AXE-FX MIDI communication orchestrator
// AIM:         Provide enhanced usability of the AXE-FX by making it possible to set the
//              AXE-FX parameters with a hardware interface (knobs/switches of the BCR2000)
// HARDWARE:    ARDUINO MEGA 128, 4 MIDI ports with a MIDI-IN and MIDI-OUT for each port.
// CREATOR:     Eric FEUILLEAUBOIS
// LICENSE:     GNU license v3 - That means OPEN SOFWARE, COPYLEFT and hope it's useful to you
/////////////////////////////////////////////////////////////////////////////////////////////////


#constant VERSION "113"

#inherit "4DGL_16bitColours.fnc"
#inherit "C_like_defines.fnc"
#include "Operational Parameters.fnc"
#include "Useful functions.fnc"
#include "MidyAX Defines.fnc"
#include "DEBUG.fnc"
#constant TRUE  1
#constant FALSE 0

#MODE RUNFLASH

#CONST      //Define the RX state machine states
    WAITING := 0x00,    // Waiting for new message to start.
    STARTED            // Processing message
#END
#CONST                      //Define misc Items (buffer sizes, etc)
    RX_BUF_SIZE := 256,     //Size of the receive buffer for serial port
    TX_BUF_SIZE := 1,      //Size of the transmit buffer for serial port
    RX_MSG_MAX_SIZE:= 401 // 1/2 the Max length if an incoming message, not including "wrapper" of $ or CR
    RX_MSG_MIN_SIZE := 2;
#END
//*************************************************************************************************************************
// ----------------------------------------------
//       Define any Global Variables here
// ----------------------------------------------
var tx_buf[TX_BUF_SIZE];                        //This is the TX buffer.  It will hold 2x TX_BUF_SIZE bytes
var rx_buf[RX_BUF_SIZE];                        //This is the RX buffer.  It will hold 2x RX_BUF_SIZE bytes

var DP; // pointer to disk struct



/////////////////
// Display Global Variables
var XX, YY, MAX_X, MAX_Y;
var lineColor;
var i, j, k, index;
var effectTypeLabel[LABEL_MAX_LENGTH];
var screenType := -1, last_displayed_screenType := -1; // The screen type to be displayed

// UNITs
var units[MAX_NUMBER_OF_UNITS];

////////////////////////////
// Control Page Variables
var controlPage_Parameter_Labels[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];
var controlPage_RawValues[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];
var controlPage_MIDIValues[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];
var controlPage_ID_ModValList[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];
var controlPage_Unit[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];
var controlPage_Effect_Block_ID[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];
var controlPage_Effect_Type_ID[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];
var controlPage_Param_State[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];

//var controlPages_EffectType_ID[ BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ];  Not necessary for now

// Tables for list of Effect Types map to a BCR2000 page
var Mapped_EffectType_ID[32];
var Mapped_EffetType_Label[32];  // TODO : check if 32 should be replaced by BCR2000_MAX_PRESET (30 now with 2 QA pages)

// All Effect Blocks tables
var EffectBlock_IDs[ MaxNumberOf_EffectBlocks ];
var EffectBlock_Label[MaxNumberOf_EffectBlocks];

// MODAL LISTs
#define LBS 20
var lastLoadedModalList := -1, lastLoadedEffectParametersList := -1, lastNumbModal := -1, lastNumbParam := -1;
var tempoSTR[30];
var tempoSTR2 [50];
var FP2;

var modalLabelBuffer[181]; //Contains all the labels of a modal parameter
var paramLabelBuffer[111]; //Contains all the allowed Parameter Label of an Effect Type
var paramIDBuffer[111]; //Contains all the IDs of allowed parameters

var fileName[20];
var filePtr, res, p, p2, numberOf_Units, numberOf_ModVal, numberOf_Param, length, freeMem;

#ifdef DEBUG6
    var startTime, elapsed;
#endif

// AXE-FX PRESET
var NumberOf_EffectBLocks_InPreset;
var *OBState, *XYState, *EffectTypeID, *EffectBlockID, PresetName;

// CURRENT CONTROL PAGE
var CurrentControlPage_EffectBlockID, CurrentControlPage_EffectTypeID, CurrentControlPage_OBState;
var CurrentControlPage_XYState, CurrentControlPage_SCENE, CurrentControlPage_NumberOf_Active_Controls;
var numberOf_ControlPages, numberOf_EffectBlocks;


// Defined the mode of the Display_Encoder_Infos function
#constant DISPLAY_PARAM_VALUE, DISPLAY_CUSTOM, DISPLAY_SPECIAL, DISPLAY_SPECIAL_CUSTOM
// DISPLAY_PARAM_VALUE ==> Effect Type Control Page : display of param (initialial and interactive)
// DISPLAY_CUSTOM ==> In customization mode of the Effect Type Control Page, displays the parameter labels
// DISPLAY_SPECIAL ==> Global Control Page : display of param (initialial and interactive)
// DISPLAY_SPECIAL_CUSTOM ==> In customization mode of Global Control Page, displays the Effect Type label and the Parameter labels


var  iiii := 0;




//*************************************************************************************************************************
func InitComPort()
    var private count := 0;
    if ( count > 1 )
        to(TEXT);print("Com port init number = ", count, "\n");
    else
        to(TEXT);print("Started InitComPort ()");
    endif
    count++;

    while(serin1() >= 0);                   //Empty out any pending bytes at port
    repeat
        com_SetBaud(COM1,11520);              //Set baud rate to 9600
        com1_Init(rx_buf,RX_BUF_SIZE,0);     //Set the comms RX buffer //TODO : USE qulifier to avoif parasite messages
        nbPause(5);                         //Non-blocking pause for 5 ms to see if any com errors occur
    until (!com1_Error());                   //Keep retrying until no more errors
    com1_TXbuffer(tx_buf,sizeof(tx_buf)*2,0);
    main.rx_state := WAITING;       //Since we reset the com buffer, we should discard any messages we were building
endfunc


//*************************************************************************************************************************
func nbPause(var msec)
    sys_SetTimer(TIMER0, msec);          // pause for msec ms, non blocking
    while(peekW(TMR0));
endfunc


//*************************************************************************************************************************
func init_Drive()
    var retry := 10;
    if(!(DP := file_Mount()))
        while(retry--)
            if((DP := file_Mount())) break;
        wend
        if (retry) return "Mount Failed!";
    endif
    return "Disk mounted";
endfunc


func Load_Effect_Type_Label()
    //txt_Width(1);
    //txt_Height(1);
    var labelPtr;
    // OPEN and READ MAP_ET.txt
    FP2 := file_Open("MAP_ET.txt", 'r');
    if( file_Error() > 0)
        to(TEXT);print("File MAP_ET.txt not found\n", "File ERROR = ", file_Error() );
        pause(5000);
        //continue;
    endif
    // Read number of values
    file_GetS(tempoSTR, 99, FP2);
    p := str_Ptr( tempoSTR );
    str_GetW( &p, &numberOf_ControlPages );
    for(k := 0; k < numberOf_ControlPages; k++)
        p := str_Ptr( tempoSTR2 );
        str_Copy(p, "");
        res := file_GetS(tempoSTR2, 99, FP2);
        str_GetW( &p, &( Mapped_EffectType_ID[k] ) );
        //to(TEXT); print("Line ",k, " read = ", [STR] tempoSTR2, "\n");
        p++; // To move pointer after the space char
        length := str_Length(p); // length of the remaining string which is the label
        //to(TEXT); print("Length till EoL ", k, " = ", length, "\n");
        Mapped_EffetType_Label[k] := mem_Alloc( length );
        if( Mapped_EffetType_Label[k] == 0 )
            to(TEXT); print("Memory ALLOC error for Mapped_EffetType_Label n°", k );  pause(5000);
        endif
        labelPtr := str_Ptr( Mapped_EffetType_Label[k] );
        str_CopyN(labelPtr, p, length);
        //to(TEXT); print("Value stored in Mapped_EffectType_ID[", k, "] = ",  Mapped_EffectType_ID[k], "\n");
        //to(TEXT); print("Value stored in Mapped_EffetType_Label[", k, "] = ", [STR] Mapped_EffetType_Label[k], "\n");
        if( file_Error() == FE_EOF && k < numberOf_ControlPages-1)
            to(TEXT); print("File MAP_ET.txt: EoF at k =", k, "\n", "File ERROR = ", file_Error() );  pause(5000);
            break;
        endif
    next
    res := file_Close(FP2);
    if( res == 0)
        to(TEXT); print("File MAP_ET.txt  not closed\n", "File ERROR = ", file_Error() );  pause(5000);
    endif
endfunc


func Load_Effect_BLock_Label()
    //txt_Width(1);
    //txt_Height(1);
    var labelPtr;
    // OPEN and READ EffectBl.txt
    FP2 := file_Open("EffectBl.txt", 'r');
    if( file_Error() > 0)
        to(TEXT);print("EffectBl.txt not found\n", "File ERROR = ", file_Error() );
        pause(5000);
        //continue;
    endif
    // Read number of values
    file_GetS(tempoSTR, 99, FP2);
    p := str_Ptr( tempoSTR );
    str_GetW( &p, &numberOf_EffectBlocks );
        //to(TEXT); print("numberOf_EffectBlocks ",numberOf_EffectBlocks, "\n");
    for(k := 0; k < numberOf_EffectBlocks; k++)
        p := str_Ptr( tempoSTR2 );
        str_Copy(p, "");
        res := file_GetS(tempoSTR2, 99, FP2);
        str_GetW( &p, &( EffectBlock_IDs[k] ) );
            //to(TEXT); print("Line ",k, " read = ", [STR] tempoSTR2, "\n");
        p++; // To move pointer after the separating space char
        length := str_Length(p); // length of the remaining string which is the label
            //to(TEXT); print("Length till EoL ", k, " = ", length, "\n");
        EffectBlock_Label[k] := mem_Alloc( length );
        if( EffectBlock_Label[k] == 0 )
            //to(TEXT); print("Memory ALLOC error for EffectBlock_Label n°", k );
            pause(5000);
            return;
        endif
        labelPtr := str_Ptr( EffectBlock_Label[k] );
        str_CopyN(labelPtr, p, length);
        //to(TEXT); print("Value stored in EffectBlock_IDs[", k, "] = ",  EffectBlock_IDs[k], "\n");
        //to(TEXT); print("Value stored in EffectBlock_Label[", k, "] = ", [STR] EffectBlock_Label[k], "\n");
        if( file_Error() == FE_EOF && k < numberOf_EffectBlocks-1)
            to(TEXT); print("File EffectBl.txt: EoF at k =", k, "\n", "File ERROR = ", file_Error() );  pause(5000);
            break;
        endif
    next
    res := file_Close(FP2);
    if( res == 0)
        to(TEXT); print("File EffectBl.txt  not closed\n", "File ERROR = ", file_Error() );  pause(5000);
    endif
endfunc



//*************************************************************************************************************************
func main()
    var bytesatport;
    var LOGO; //File handle for LOGO file

    var private rx_state := WAITING;         //Holds the current message state. Retained between calls (because of private)
    var private msg_buf[RX_MSG_MAX_SIZE];   //Holds the Message ASCII data. Retained between calls
    var private msgIndex;                   //Holds message body index. Retained between calls
    var private msgPtr;                     //String pointer Retained between calls
    var perm_msgPtr;                        //Sting pointer to beginning of msg_buf
    var comByte;                            //Next byte to be processed from RX buffer
    var i;

    // Allocate Memory
    for (i := 0; i < BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER ; i++)
    controlPage_Parameter_Labels[i] := mem_Alloc( LABEL_MAX_LENGTH );
        p :=str_Ptr( controlPage_Parameter_Labels[i] );
        str_Copy( p, "");
    next

    for (i := 0; i < MAX_NUMBER_OF_UNITS ; i++)
    units[i] := mem_Alloc( UNIT_MAX_LENGTH );
        p :=str_Ptr( units[i] );
        str_Copy( p, "");
    next

    OBState := mem_Alloc(MaxNumberOfControlPages);
    XYState := mem_Alloc(MaxNumberOfControlPages);
    EffectTypeID := mem_Alloc(MaxNumberOfControlPages);
    EffectBlockID := mem_Alloc(MaxNumberOfControlPages);
    PresetName := mem_Alloc(18);


    // Init the com port.
    InitComPort();

    // Init the Display
    gfx_Set(SCREEN_RES,1);
    gfx_BGcolour(BLACK);
    //gfx_Cls();
    MAX_X := gfx_Get(X_MAX);
    MAX_Y := gfx_Get(Y_MAX);
    gfx_Set(PEN_SIZE, OUTLINE);
    lineColor := DARKRED;

    putstr( init_Drive() );

    // Display the LOGO if present ON THE SD CARD
    if(file_Exists("LOGO_4.gci"))
        LOGO := file_Open("LOGO_4.gci", 'r');
        file_Image(0,0, LOGO);
        file_Close(LOGO);
    else
        putstr("File ""LOGO_4.gci"" not found\n");  pause(2000);
    endif


#ifdef DEBUG5
   gfx_MoveTo(0,50);
   freeMem := mem_Heap();
   print("FreeMem = ", freeMem, "\n");
#endif


   var k;
   if(!file_Exists("Units.txt"))
        putstr("File ""Units.txt"" not found\n");  pause(2000);
   else
        LOGO := file_Open("Units.txt", 'r');
        file_GetS(tempoSTR, 99, LOGO);
        p := str_Ptr( tempoSTR );
        str_GetW( &p, &numberOf_Units );
        //to(TEXT); print("Number of units = ", numberOf_Units, "\n");
        for(k := 0; k < numberOf_Units; k++)
            str_Copy(p, "");
            res := file_GetS(tempoSTR, 99, LOGO);
            //to(TEXT); print(k, " value = ", [STR] tempoSTR, "\n");
            p := str_Ptr( tempoSTR );
            p2 := str_Ptr( units[k] );
            str_Copy(p2, "");
            str_Copy(p2, p);
        next
        file_Close(LOGO);
   endif


    // Check that all the files containing the Parameters Modal Lists are present on the SD card
    /*for(i := 0; i < AXEFX_NumOfModalList_DEFINE; i++)
        filePtr := str_Ptr(fileName);
        str_Copy(filePtr, "");
        to(fileName);
        print("ML_", i, ".txt\0");
        //to(TEXT);
        //print([STR]fileName, "\n");
        //print( "Length =", str_Length(filePtr), "\n");
        if(!file_Exists(filePtr))
            to(TEXT);print("File", [STR] fileName,"not found\n");  pause(500);
        endif
    next*/

    // LOAD THE EFFECT TYPE labels displayed in the CONTROL PAGE state bar
    Load_Effect_Type_Label();
     // LOAD THE EFFECT BLOCK labels displayed in the QuickAccess pages
    Load_Effect_BLock_Label();

    // CHECK IF SUBPROGRAMS ARE PRESENT ON THE SD CARD
    /*var ok := 1;
    gfx_MoveTo(100,100);
    if(!file_Exists("COM_.4FN"))putstr("COMP.4FN not found\n"),ok := 0;
    if(!file_Exists("GRAPHEQ.4FN"))putstr("GRAPHEQ.4FN not found\n"),ok := 0;
    if(!file_Exists("PARAMEQ.4FN"))putstr("PAREQ.4FN not found\n"),ok := 0;
    if(!file_Exists("AMP.4FN"))putstr("AMP.4FN not found\n"),ok := 0;
    if(!ok)
        gfx_MoveTo(100,200); putstr("At least One file missing\n"); pause(2000); return;
    endif*/

    gfx_MoveTo(0,0);
    //putstr("Listening to the ARDUINO\n");

    perm_msgPtr := str_Ptr(msg_buf);
    // Listen to COM1
    repeat
        bytesatport:=com1_Count();
        if( bytesatport > 0 )
            while (bytesatport)
                //print("rx_state = ", rx_state, "\n");
                comByte := serin1();
                if (comByte < 0) continue;
                if (comByte == '$')
                    //putstr("$ received\n");
                    rx_state := STARTED;
                    msgIndex := 0;
                    msgPtr := perm_msgPtr;
                    //mem_Set(msg_buf,0,sizeof(msg_buf)*2);
                    continue;
                endif

                if( rx_state == STARTED )
                    if ( comByte == 13 )
                        //putstr("13 received\n");
                        if( rx_state == STARTED && msgIndex >= RX_MSG_MIN_SIZE )
                            str_PutByte(msgPtr,'\0');
                            //Process_Msg( &msg_buf[0], msgIndex );
                            Process_Msg( &msg_buf[0]);
                            rx_state := WAITING;
                            break;
                        else
                            rx_state := WAITING;
                        endif
                    else
                        if ( msgIndex > RX_MSG_MAX_SIZE )
                            rx_state := WAITING;
                        else
                            //print("BYTE = ", comByte, "\n");
                            str_PutByte(msgPtr++,comByte);
                            msgIndex++;
                        endif
                    endif
                endif
            wend
        else
            if( com1_Error() )
                InitComPort();
            endif
        endif
    forever

endfunc


//*************************************************************************************************************************
//func Process_Msg( var *msgBuf, var bufLength )
func Process_Msg( var *msgBuf )
    var private A:=-1, B:=-1, C:=-1, D:=-1 , E:=-1, Y:=-1, Z:=-1;
    var private ScreenShot_nb := 0;
    var private receivedControlNumber;

    var msgPtr, msgID, labelPtr;
    var controlNumber, paramID;
    var label[LABEL_MAX_LENGTH];
    var i;



    #ifdef DEBUG
        //putstr("Start Process_Msg\n");
    #endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Processing received message
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    msgPtr := str_Ptr(msgBuf);

    // READ THE MESSAGE ID (A, B, C, ...)
    str_GetC(&msgPtr,&msgID);
    #ifdef DEBUG2
        print("Message ID = ", [CHR] msgID, "\n");
        str_Printf ( &msgPtr , "msgBuf = %s\n" );
        msgPtr := str_Ptr(msgBuf); msgPtr++;
    #endif

    switch( msgID )
        // Receives the Current Preset description
        case 65 :  // AAAAAAAAAAA
            A := 1;
            //B := -1;
            //C := -1;

            var tempoVal;
            str_GetW(&msgPtr,&NumberOf_EffectBLocks_InPreset);
            //to(TEXT); print("NumberOf_EffectBLocks_InPreset =", NumberOf_EffectBLocks_InPreset, "\n"  );
            for (i := 0; i < NumberOf_EffectBLocks_InPreset; i++)
                 str_GetW(&msgPtr,&tempoVal);
                 if(tempoVal != i)
                    to(TEXT); print("Error in A message at i =", i, " received val = ", tempoVal, "\n"  ); pause(20000);
                 endif
                 str_GetW( &msgPtr, &( EffectBlockID[i] ) );
                 str_GetW( &msgPtr, &( EffectTypeID[i] ) );
                 str_GetW( &msgPtr, &( OBState[i] ) );
                 str_GetW( &msgPtr, &( XYState[i] ) );

                //to(TEXT); print("EffectBlockID[i] = ", EffectBlockID[i], " "  );
                //to(TEXT); print("EffectTypeID[i] = ", EffectTypeID[i], " "  );
                //to(TEXT); print("OBState[i] = ", OBState[i], " "  );
                //to(TEXT); print("XYState[i] = ", XYState[i], "\n"  );
            next
            msgPtr++; // To move pointer after the space char
            length := str_Length(msgPtr); // length of the remaining string which is the label
            labelPtr := str_Ptr(PresetName);
            //copy_nstr(length, &msgPtr, labelPtr);
            str_CopyN(labelPtr, msgPtr, length);
            #ifdef DEBUG77
                gfx_MoveTo(0,10);
                to(TEXT); print("_A_ message received    " );
                to(TEXT); print("PresetName = ", [STR] PresetName, "\n"  );
                to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  E = ", E ,"  Y = ", Y, "  Z = ", Z,"\n");
                //pause(5000);
            #endif
        break;

        case 66 :  // BBBBBBBBBB
            // FREE the memory of the last loaded Modal List (of the previously selected Control Page)
            var k;
            if( lastNumbModal > 0)
                for( k := 0; k < lastNumbModal; k++)
                    res := mem_Free( modalLabelBuffer[k] );
                    if ( res == 0  )
                        gfx_MoveTo(0,60);
                        to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" );
                    else
                        //print("DE-ALLOCATED = ", res, "\n" );
                        //pause(1000);
                    endif
                next
            endif
            // Memory de-allocation of last loaded list of parameter labels
            if( lastNumbParam> 0)
                for( k := 0; k < lastNumbParam; k++)
                    res := mem_Free( paramLabelBuffer[k] );
                    if ( res == 0  )
                        gfx_MoveTo(0,60);
                        to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" );
                    else
                        //print("DE-ALLOCATED = ", res, "\n" );
                        //pause(100);
                    endif
                next
            endif

            lastLoadedModalList := -1; lastLoadedEffectParametersList := -1; lastNumbModal := -1, lastNumbParam := -1;

            str_GetW( &msgPtr, &( CurrentControlPage_EffectBlockID ) );
            str_GetW( &msgPtr, &( CurrentControlPage_EffectTypeID ) );
            str_GetW( &msgPtr, &( CurrentControlPage_OBState ) );
            str_GetW( &msgPtr, &( CurrentControlPage_XYState ) );
            str_GetW( &msgPtr, &( CurrentControlPage_SCENE ) );
            str_GetW( &msgPtr, &( CurrentControlPage_NumberOf_Active_Controls ) );
            receivedControlNumber := 0;

            B := CurrentControlPage_NumberOf_Active_Controls;
            //C := -1; // The Control Page has changed ==> Parameter init vals have to be received

            //to(TEXT); print("CurrentControlPage_EffectBlockID =", CurrentControlPage_EffectBlockID, "\n"  );
            //to(TEXT); print("CurrentControlPage_EffectTypeID =", CurrentControlPage_EffectTypeID, "\n"  );
            //to(TEXT); print("CurrentControlPage_OBState =", CurrentControlPage_OBState, "\n"  );
            //to(TEXT); print("CurrentControlPage_XYState =", CurrentControlPage_XYState, "\n"  );
            //to(TEXT); print("CurrentControlPage_SCENE =", CurrentControlPage_SCENE, "\n"  );

            msgPtr++; // To move pointer after the space char
            length := str_Length(msgPtr); // length of the remaining string which is the label
            labelPtr := str_Ptr(effectTypeLabel);
            //copy_nstr(length, &msgPtr, labelPtr);
            str_CopyN(labelPtr, msgPtr, length);

            #ifdef DEBUG2
                print("Received message B value = ", msgvalue,"\n");
                print("String length msgPtr = ", length,"\n");
                labelPtr := str_Ptr(effectTypeLabel);
                str_Printf ( &labelPtr , "labelPtr = %s\n" );
            #endif
            //pause(20000);

            // INITIALIZATION OF THE PARAMETER LABELS DISPLAY ON THE CURRENT CONTROL PAGE
            for (i := 0; i < BCR2000_ENCODER_NUMBER + BCR2000_PUSH_BUT_NUMBER; i++)
                //print(i," = ,", controlPage_Parameter_Labels[i], ";");
                *controlPage_Parameter_Labels[i] := '\0';
                //print(i," = ,", controlPage_Parameter_Labels[i], ";");
            next
            #ifdef DEBUG77
                to(TEXT); print("_B_ message received " );
                to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  E = ", E, "  Y = ", Y, "  Z = ", Z,"\n");
            #endif
        break;


        // RECEPTION OF THE PARAMETER INFO FOR ONE CONTROL ELEMENT : Param Number, Param Label, Param Unit, Modal List of the param
        case 67 :  // CCCCCCCCCC
            // READ the message
            str_GetW( &msgPtr, &controlNumber );
            str_GetW( &msgPtr, &(controlPage_Effect_Block_ID[controlNumber]) );
            str_GetW( &msgPtr, &(controlPage_Effect_Type_ID[controlNumber]) );
            str_GetW( &msgPtr, &paramID );
            str_GetW( &msgPtr, &(controlPage_Unit[controlNumber]) );
            str_GetW( &msgPtr, &(controlPage_ID_ModValList[controlNumber]) );
            str_GetW( &msgPtr, &(controlPage_Param_State[controlNumber]) );

#ifdef DEBUG77
            gfx_Cls();
            gfx_MoveTo(0,0);
            print("ControlNumber = ", controlNumber,"\n");
            print("controlPage_Effect_Block_ID[controlNumber] = ", controlPage_Effect_Block_ID[controlNumber],"\n");
            print("Received message C, for Effect Type ID = ", effectType_ID,"\n");
            print("paramID = ", paramID,"\n");
            print("controlPage_ID_ModValList[controlNumber] = ", controlPage_ID_ModValList[controlNumber],"\n");
            print("controlPage_Unit[controlNumber] = ", controlPage_Unit[controlNumber],"\n");
            //pause(2000);
#endif

            labelPtr := str_Ptr(label);
            msgPtr++;
            length := str_Length(msgPtr);
            if( length > LABEL_MAX_LENGTH-1)
                 length := LABEL_MAX_LENGTH-1;
            endif
            //copy_nstr(LABEL_MAX_LENGTH, &msgPtr, labelPtr);
            copy_nstr(length, &msgPtr, labelPtr);
            labelPtr := str_Ptr(label);


            labelPtr := str_Ptr(label);
            length := str_Length(labelPtr);
            msgPtr :=  str_Ptr(controlPage_Parameter_Labels[controlNumber]);
            //copy_nstr(LABEL_MAX_LENGTH-1, &labelPtr, msgPtr);
            copy_nstr(length, &labelPtr, msgPtr);
            msgPtr :=  str_Ptr(controlPage_Parameter_Labels[controlNumber]);
            #ifdef DEBUG77
                //gfx_MoveTo(0,0);
                print("String length msgPtr= ", length,"\n");
                //print("labelPtr = ");
                print("controlPage_Parameter_Labels[controlNumber] = ", [STR] controlPage_Parameter_Labels[controlNumber], "\n");
                pause(5000);
            #endif
            C := 1; // At least one C message has been received from ARDUINO MEGA

            #ifdef DEBUG77
                to(TEXT); print("_C_ message received " );
                to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  E = ", E, "  Y = ", Y, "  Z = ", Z,"\n");
            #endif
        break;


        case 68 :  // DDDDDDDDD
            str_GetW(&msgPtr,&controlNumber);
            str_GetW(&msgPtr,&controlPage_MIDIValues[controlNumber]);
            str_GetD(&msgPtr,&controlPage_RawValues[controlNumber]);
            //to(TEXT); print("controlNumber = ", controlNumber, "  controlPage_RawValues[controlNumber] = ", controlPage_RawValues[controlNumber], "\n");print("controlPage_MIDIValues[controlNumber] = ", controlPage_MIDIValues[controlNumber], "\n");
            D := 1; // At least one D message has been received from ARDUINO MEGA
            #ifdef DEBUG77
                to(TEXT); print("_D_ message received " );
                to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  E = ", E, "  Y = ", Y, "  Z = ", Z,"\n");
            #endif
        break;


        // Sreen Type Message --> Cause display of that screen type
        case 69 :  // EEEEEEEEEEE
            str_GetW(&msgPtr,&screenType);
            //to(TEXT);print("screenType = ", screenType, "\n");return;
            #ifdef DEBUG77
                to(TEXT); print("_E_ message received. screenType = ", screenType,  "  ");
                to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  E = ", E, "  Y = ", Y, "  Z = ", Z,"\n");
            #endif
            E:= screenType;
        break;


        case 89 :  // YYYYYYYYY
            str_GetW(&msgPtr,&controlNumber);
            str_GetW(&msgPtr,&controlPage_MIDIValues[controlNumber]);
            //print("ControlNumber = ", controlNumber, "\n");
            //print("controlPage_MIDIValues[controlNumber] = ", controlPage_MIDIValues[controlNumber], "\n");
            //to(TEXT); print("controlNumber = ", controlNumber, "  controlPage_RawValues[controlNumber] = ", controlPage_RawValues[controlNumber], "\n");
            //return;
            Y := controlNumber;
            Z := -1;
            txt_Bold(ON);
        break;


        case 90 :  // ZZZZZZZZZ
            str_GetW(&msgPtr,&controlNumber);
            str_GetW(&msgPtr,&controlPage_MIDIValues[controlNumber]);
            str_GetD(&msgPtr,&controlPage_RawValues[controlNumber]);
            //print("ControlNumber = ", controlNumber, "\n");
            //print("controlPage_MIDIValues[controlNumber] = ", controlPage_MIDIValues[controlNumber], "\n");
            //to(TEXT); print("controlNumber = ", controlNumber, "  controlPage_RawValues[controlNumber] = ", controlPage_RawValues[controlNumber], "\n");
            //return;
            Y := -1;
            Z := controlNumber;
            txt_Bold(ON);

            #ifdef DEBUG77
                 gfx_MoveTo(0,0);
                to(TEXT); print("_Z_ message received. controlNumber = ", controlNumber,  "  ");
                to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  E = ", E, "  Y = ", Y, "  Z = ", Z,"\n");
            #endif
        break;


        case 49 :   // 1111111111
            gfx_MoveTo(0,420);
            filePtr := str_Ptr(fileName);
            str_Copy(filePtr, "");
            to(fileName);
            print("SC_", ScreenShot_nb, ".gci\0");
            filePtr := str_Ptr(fileName);
            if( file_Exists( filePtr ) == 1) file_Erase( filePtr );
            FP2 := file_Open(filePtr, 'w'); // open a file to save the image
            if( file_Error() > 0)
                to(TEXT);print("Can't OPEN file", [STR] fileName, " for Screen Shot n° ", ScreenShot_nb, "\n", "File ERROR = ", file_Error(), "\n" );
                pause(1000);
                //continue;
            endif
            file_ScreenCapture(0,0,MAX_X,MAX_Y, FP2);// save an area
            file_Close(FP2);
            to(TEXT); print("Screen Shot n° ", ScreenShot_nb, " DONE\n");
            ScreenShot_nb++;
            return;
        break;


        case 50 :   // 222222222222
            to(TEXT); print( [STR] msgPtr,"\n");
            return;
        break;
    endswitch

    txt_Set(TEXT_COLOUR, WHITE);
    txt_BGcolour(BLACK);



    // Process single parameter value change
    if( Z != -1)
        Display_Encoder_Infos( DISPLAY_PARAM_VALUE, Z );
        #ifdef DEBUG77
            gfx_MoveTo(0,20);
            to(TEXT); print("Display_Encoder_Infos called. Z = ", Z);
        #endif
        Z := -1;
    endif

    // Process single controller cutomization
    if( Y != -1 )
        Display_Encoder_Infos( DISPLAY_CUSTOM, Y );
        Y := -1;
    endif



    ///////////////////////////////////////////////////////////////////////////
    // According to the STATE calls the right functions
    ///////////////////////////////////////////////////////////////////////////
    // Param A determines the mode (or main screen)

    #ifdef DEBUG7
        if( screenType != -1 )
            gfx_MoveTo(0,10);
            to(TEXT); print("\n screenType = ", screenType, "\n");
            to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  E = ", E, "  Y = ", Y, "  Z = ", Z,"\n");
            pause(2000);
        endif
    #endif

    switch( screenType )
        case -1:
            return;
        break;

        case EFFECT_TYPE_CONTROL_PAGE :
        case QUICKACCESS_CONTROL_PAGE :
        case CUSTOM_EFFECT_TYPE_CONTROL_PAGE :
        case CUSTOM_QUICKACCESS_CONTROL_PAGE :
        case CUSTOM_QUICKACCESS_CONTROL_PAGE_EFFECTBLOCK :
            //txt_FGcolour(WHITE);
            //txt_Bold(ON);
            //txt_Width(1);
            //txt_Height(1);
            //gfx_MoveTo(10,10 +iiii*20);
            //iiii++;
            //to(TEXT); print("A = ", A, "  B = ", B, "  C = ", C, "  D = ", D, "  Y = ", Y, "  Z = ", Z,"\n");
            //pause(500);

            // EFFECT TYPE CONTROL PAGE SCREEN
            if( B == CurrentControlPage_NumberOf_Active_Controls && C == 1 && D == 1 )
                screen_Display_ControlPage( );
            endif
        break;

        case INIT_SCREEN :
            // INIT_SCREEN
            var LOGO;
            if( file_Exists("LOGO_4.gci") )
                LOGO := file_Open("LOGO_4.gci", 'r');
                file_Image(0,0, LOGO);
                file_Close(LOGO);
            else
                putstr("File ""LOGO_4.gci"" not found\n");  pause(2000);
            endif
        break;

        case OPERATIONAL_PARAMETERS_SCREEN :
            // OPERATIONAL PARAMETERS SCREEN
            gfx_Cls();
            gfx_MoveTo(10,10);
            print("Operationam Parameters SCREEN\n");pause(100);
            return;
        break;
    endswitch
    last_displayed_screenType := screenType;
    screenType := -1;

endfunc

//*************************************************************************************************************************
//*************************************************************************************************************************
func screen_Display_ControlPage( )
    //////////////////////////////////////////////////
    ///////// Draw the ControlPage screen
    //////////////////////////////////////////////////
    var start_X, start_Y, controlDisplayHeight;
    var tempoChar;
    var strNum;
    var labPtr, labStr1Ptr, labStr2Ptr, labStr3Ptr, curPtr;
    var labStr1[10], labStr2[10], labStr3[10];
    var labLength, str1Length, str2Length, str3Length, curLength;

    //init_Drive();

    gfx_Cls();


    //gfx_MoveTo(0,0);
    //print("Control page for Effect Type = ", controlPageNumber,"\n");
    //print("Control Page Screen\n");

    // If the Effect Block list is displayed
    controlDisplayHeight := MAX_Y;
    if( OP_EffectBlock_Display == 1)
         controlDisplayHeight := MAX_Y * 5/6;
    else
        if( OP_EffectBlock_Display == 2)
            controlDisplayHeight := MAX_Y * 4/6;
        endif
    endif

    txt_FontID (FONT1);
    txt_Width(2);
    txt_Height(2);
    txt_Bold(ON);
    txt_FGcolour(YELLOW);
    txt_BGcolour(DARKRED);

    // Top band backgroud
    gfx_RectangleFilled( 0, 0, MAX_X, (MAX_Y+1) / 24 , DARKRED);

    to(TEXT);
    print("PRESET: ", [STR] PresetName);
    //print("BlockID =", CurrentControlPage_EffectBlockID  );
    //print(" TypeID =", CurrentControlPage_EffectTypeID  );

    gfx_MoveTo( (MAX_X+1) /8 *5, 0);
    if( CurrentControlPage_OBState == 0)
        print("OFF");
    else
         print("ON");
    endif
    if( CurrentControlPage_XYState == 0)
        print(" Y");
    else
         print(" X");
    endif
    print(" SCENE ", CurrentControlPage_SCENE + 1  );

    // Displays the version of the uVGA software
    txt_FGcolour(WHITE);
    print(" ", [STR] VERSION );

    // Draw vetical lines
    start_X := (MAX_X+1) /8;
    start_Y := (MAX_Y+1) /24;
    for(i := 0; i < 9; i++)
        XX := ( MAX_X * i ) / 8;
        gfx_Line( XX, start_Y, XX,  MAX_Y, lineColor);
    next


    if( screenType == EFFECT_TYPE_CONTROL_PAGE )
        ///////////////////////////////////////////////////////////////////////////
        // Display the Effect Type Strip
        ///////////////////////////////////////////////////////////////////////////
        txt_FGcolour(GRAY);
        txt_Bold(OFF);

        XX := ( MAX_X +1) / 8;
        //to(TEXT); print("MAX_X = ", MAX_X," MAX_X/8 = ", MAX_X/8, "\n");
        //to(TEXT); print("MAX_Y = ", MAX_Y," MAX_Y/12 = ", MAX_Y/12, "\n");  pause(10000);
        index :=0;
        for(i := 1; i <= 2; i++)
            YY := ( (MAX_Y+1) / 12) * (i-1) + ((MAX_Y+1) / 24);
            gfx_Line( 0, YY, MAX_X,  YY, lineColor);
            for(j := 1; j <= 8; j++)
                txt_Width(1);
                txt_Height(2);
                txt_FontID (FONT1);
                if( Mapped_EffectType_ID[index] -2 == CurrentControlPage_EffectTypeID )
                    txt_Bold(ON);
                    txt_FGcolour(YELLOW);
                    txt_BGcolour(RED);
                    if( CurrentControlPage_OBState == 1)
                        txt_BGcolour(RED);
                        gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24)  ,   (XX*j) -1   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , XX*(j-1) , ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24), RED);
                    endif
                else
                    txt_FGcolour(GRAY);
                    txt_BGcolour(BLACK);
                    txt_Bold(OFF);
                    for( k:=0; k < NumberOf_EffectBLocks_InPreset; k++)
                        if( EffectTypeID[k] == Mapped_EffectType_ID[index] -2)
                            txt_FGcolour(WHITE);
                            txt_Bold(ON);
                            if( OBState[k] == 1)
                                txt_FGcolour(BLACK);
                                txt_BGcolour(WHITE);
                                gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24)  ,   (XX*j)-1   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , XX*(j-1)  , ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24), WHITE);
                            endif
                            break;
                        endif
                    next
                endif
                gfx_MoveTo( XX * (j-1) + 2, YY + MAX_Y/64 );
                putstr( Mapped_EffetType_Label[index] );


                if( Mapped_EffectType_ID [index+16 ] -2 == CurrentControlPage_EffectTypeID )
                    txt_Bold(ON);
                    txt_FGcolour(YELLOW);
                    txt_BGcolour(RED);
                    if( CurrentControlPage_OBState == 1)
                        txt_BGcolour(RED);
                        gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24) ,   (XX*j)-2  ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , (XX*j)-2 , ((MAX_Y+1)/12)* i -2 + ((MAX_Y+1) / 24), RED);
                    endif
                else
                    txt_BGcolour(BLACK);
                    txt_FGcolour(GRAY);
                    txt_Bold(OFF);
                    for (k :=0; k < NumberOf_EffectBLocks_InPreset; k++)
                        if ( EffectTypeID[k] == Mapped_EffectType_ID [index+16] -2)
                            txt_FGcolour(WHITE);
                            txt_Bold(ON);
                            if( OBState[k] == 1)
                                txt_FGcolour(BLACK);
                                txt_BGcolour(WHITE);
                                gfx_TriangleFilled(  XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24) ,   (XX*j)-2   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , (XX*j)-2 , ((MAX_Y+1)/12)*i -2 + ((MAX_Y+1) / 24), WHITE);
                            endif
                            break;
                        endif
                    next
                endif
                gfx_MoveTo( XX * (j-1) + MAX_X/12, YY + MAX_Y/24 + 2 );
                putstr( Mapped_EffetType_Label[index+16] );

                gfx_Line(   XX*(j-1)   ,   ((MAX_Y+1)/12) * i -2 + ((MAX_Y+1) / 24) ,   XX*j   ,   ((MAX_Y+1)/12) * (i-1) + ((MAX_Y+1) / 24)  , lineColor );
                index++;
            next
        next
    endif

    if(      screenType == CUSTOM_EFFECT_TYPE_CONTROL_PAGE
          || screenType == CUSTOM_QUICKACCESS_CONTROL_PAGE
          || screenType == CUSTOM_QUICKACCESS_CONTROL_PAGE_EFFECTBLOCK
          || screenType == QUICKACCESS_CONTROL_PAGE )
        gfx_RectangleFilled( 0, ((MAX_Y+1)/24) +1, MAX_X, (MAX_Y+1)/12 , BLACK);
        txt_Width(2);
        txt_Height(3);
        txt_FGcolour(YELLOW);
        txt_BGcolour(BLACK);
        txt_FontID (FONT1);
        txt_Bold(OFF);
        gfx_MoveTo( ( MAX_X +1) / 5, (MAX_Y+1) / 10 );
        to(TEXT);
        if( screenType == CUSTOM_EFFECT_TYPE_CONTROL_PAGE ) print("Control Page CUSTOMIZATION \n");
        if( screenType == CUSTOM_QUICKACCESS_CONTROL_PAGE ) print("QuickAcces Page CUSTOMIZATION \n");
        if( screenType == CUSTOM_QUICKACCESS_CONTROL_PAGE_EFFECTBLOCK ) print("QA Page CUSTOM - EFFECT BLOCKs \n");
        if( screenType == QUICKACCESS_CONTROL_PAGE ) print("QUICKACCESS PAGE \n");
    endif



#ifdef DEBUG4
                gfx_MoveTo(0,420);
                freeMem := mem_Heap();
                to(TEXT); print("FreeMem = ", freeMem, "\n");
                //print("index = ", index, "  ID_ModValList = ", [DEC] controlPage_ID_ModValList[index],"\n");
#endif



    ////////////////////////////////////////////////////////////////////////////////////
    // Display the 40 controled parameters (32 encoders + 8 buttons) in square boxes
    ////////////////////////////////////////////////////////////////////////////////////
    index :=0;
    for(i := 1; i < 6; i++)
        YY := ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24);
            gfx_Line( 0, YY, MAX_X,  YY, lineColor);
        for(j := 1; j <= 8; j++)
            //labPtr :=  str_Ptr(controlPage_Parameter_Labels[index]);
            //str_Printf( &labPtr , "%s\n" );

            labPtr :=  str_Ptr(controlPage_Parameter_Labels[index]);
            labLength := str_Length(labPtr);

            // IF THERE is a LABEL --> the PARAMETER is displayed
            //if( labLength > 0 )
            if( controlPage_Param_State[ index ] != NO_PARAMETER )
                labStr1Ptr := str_Ptr(labStr1); labStr2Ptr := str_Ptr(labStr2); labStr3Ptr := str_Ptr(labStr3);
                str_PutByte(labStr1Ptr, '\0'); str_PutByte(labStr2Ptr, '\0'); str_PutByte(labStr3Ptr, '\0');
                curPtr := labStr1Ptr;
                strNum := 0;
                curLength :=0; str1Length := 0; str2Length := 0; str3Length := 0;

                //gfx_MoveTo(0,0);
                //print( "labLength = ", labLength, "\n" );
                //print( "controlNumber = ", controlNumber, "\n" );

                //gfx_MoveTo( XX * (j-1) + 3, YY + 2 ); // + MAX_Y/128
                gfx_MoveTo( XX * (j-1) , YY+1 );
                txt_Width(1);
                txt_Height(1);
                txt_FGcolour(WHITE);
                txt_BGcolour(lineColor);
                txt_FontID (FONT1);
                txt_Bold(OFF);
                //print( " ", index + 1 , " ");
                print( index + 1 );

                gfx_MoveTo( XX * (j-1) + MAX_X/64, YY + MAX_Y/28 );

                for(k := 0; k < labLength; k++)
                    str_GetC(&labPtr, &tempoChar);
                    if(  tempoChar == 32)
                        str_PutByte(curPtr, '\0');
                        if( strNum == 0 )
                            str1Length := curLength; curLength := 0;
                            curPtr := labStr2Ptr; strNum := 1;
                        else
                            if( strNum == 1 )
                                str2Length := curLength; curLength := 0;
                                curPtr := labStr3Ptr; strNum := 2;
                            endif
                        endif
                    else
                        str_PutByte( curPtr++  ,tempoChar);
                        curLength++;
                    endif
                next
                if( strNum == 0 ) str1Length := curLength;
                if( strNum == 1 ) str2Length := curLength;
                if( strNum == 2 ) str3Length := curLength;
                str_PutByte(curPtr, '\0');

                //str_Printf( &labStr1Ptr , "%s\n" ); str_Printf( &labStr2Ptr , "%s\n" ); str_Printf( &labStr3Ptr , "%s" );

                labStr1Ptr := str_Ptr(labStr1);
                labStr2Ptr := str_Ptr(labStr2);
                labStr3Ptr := str_Ptr(labStr3);

                //print( "   str1Length = ", str1Length, "\nstr2Length = ", str2Length, "\nstr3Length = ", str3Length);
                //pause(5000);

                txt_FGcolour(RED);
                txt_BGcolour(BLACK);
                txt_FontID (FONT1);
                txt_Width(1);
                txt_Height(1);
                txt_Bold(ON);
                if( str1Length + str2Length <= 9)
                    if( str1Length > 0 ) str_Printf( &labStr1Ptr  , "%s" );
                    if( str2Length > 0 ) str_Printf( &labStr2Ptr  , " %s" );
                    gfx_MoveTo( XX * (j-1) + MAX_X/64, YY + MAX_Y/28 + 12 );
                    if( str3Length > 0 ) str_Printf( &labStr3Ptr  , "%s" );
                else
                    if( str1Length > 0 ) str_Printf( &labStr1Ptr  , "%s" );
                    gfx_MoveTo( XX * (j-1) + MAX_X/64, YY + MAX_Y/28 + 12 );
                    if( str2Length > 0 ) str_Printf( &labStr2Ptr  , "%s" );
                    if( str3Length > 0 ) str_Printf( &labStr3Ptr  , " %s" );
                endif

                txt_Bold(OFF);
                // Call the function displaying the Parameter value
                Display_Encoder_Infos( DISPLAY_PARAM_VALUE , index );

                // IF QuickAccess Pages --> Display the AMP BLOCK label
                if(    screenType == QUICKACCESS_CONTROL_PAGE
                    || screenType == CUSTOM_QUICKACCESS_CONTROL_PAGE
                    || screenType == CUSTOM_QUICKACCESS_CONTROL_PAGE_EFFECTBLOCK )
                    txt_FGcolour( LIGHTBLUE );  //(DARKGRAY);
                    if( controlPage_Param_State[ index ] == PARAMETER_ACTIVE )  txt_BGcolour( DARKRED );
                    if( controlPage_Param_State[ index ] == PARAMETER_NOT_ACTIVE )
                        txt_BGcolour( DARKBLUE );
                        gfx_RectangleFilled( XX * (j-1),
                                             YY + 1,
                                             (XX * j) -1,
                                             YY + 15,
                                             DARKGRAY);
                    endif
                    txt_FontID( FONT1 );
                    txt_Width( 1 );
                    txt_Height( 1 );
                    txt_Bold( ON );
                    gfx_MoveTo( XX * (j-1) + MAX_X/28  ,    YY +1  );
                    putstr( EffectBlock_Label[ controlPage_Effect_Block_ID[index] - 100 ] );
                    // -100 since Block IDs start at 100
                endif

                txt_Bold(OFF);
                txt_FGcolour(LIGHTBLUE);
                txt_BGcolour(BLACK);
                txt_Height(1);
                txt_Bold(OFF);

                // IF the parameter has a UNITS --> display it
                gfx_MoveTo( XX * (j-1) + 55  ,    YY + MAX_Y/9 + 15);
                if( controlPage_Unit[index] < 0 || controlPage_Unit[index] > numberOf_Units )
                    controlPage_Unit[index] := 0;
                endif
                if( controlPage_Unit[index] != 0)
                    putstr( units[ controlPage_Unit[index] ] );
                endif

                //gfx_MoveTo(0,50);
                //print( controlPage_Unit[index] , "\n");
                //pause(5000);
            endif
            // IF labLength = 0 --> Nothing to display
            index ++;
        next
    next

#ifdef DEBUG5
    gfx_MoveTo(0,50);
    freeMem := mem_Heap();
    print("FreeMem = ", freeMem, "\n");
#endif

    // TEST Image Capture --> Writing a slow
    /*var hFile, t;
    //sys_SetTimer(TIMER0, 20000);
    t := sys_T();
    hFile := file_Open("test.img", 'a'); // open a file to save the image
    file_ScreenCapture(20,20,300,300, hFile);// save an area
    file_ScreenCapture(0,0,200,200, hFile); // (save another area)
    file_Close(hFile); // now close the file
    t := sys_T() -t; //sys_GetTimer(TIMER0);
    gfx_MoveTo(0,0);
    print("time taken = ", t);

    hFile := file_Open("test.img", 'r'); // open the saved file
    file_Image(100, 100, hFile); // display the image
    file_Image(150, 180, hFile); // (display the next image)
    file_Close(hFile);*/

    return;
endfunc




func Display_Encoder_Infos( var mode, var controlNumber )
    var labPtr, labLength;

    //Display a parameter value at the right location on the screen
    i := controlNumber/8;
    j := controlNumber - ( i * 8 );
    i := i + 1;
    j := j + 1;
    XX := (MAX_X +1) / 8;
    YY :=  ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24);

    labPtr :=  str_Ptr(controlPage_Parameter_Labels[controlNumber]);
    labLength := str_Length(labPtr);
    // IF THERE is no LABEL there is no PARAMETER displayed if in DISPLAY_PARAM_VALUE mode
    #ifdef DEBUG77
            gfx_MoveTo(0,10);
            to(TEXT); print("labLength = ", labLength, " mode=", mode,"\n" );
    #endif

    if( controlPage_Param_State[ controlNumber ] == NO_PARAMETER && mode == DISPLAY_PARAM_VALUE) return;

    #ifdef DEBUG77
            to(TEXT); print("mode = ", mode, " controlNumber=", controlNumber, "controlPage_ID_ModValList[controlNumber]", controlPage_ID_ModValList[controlNumber],"\n" );
            pause (5000);
    #endif

    if( mode == DISPLAY_PARAM_VALUE
        && ( controlPage_ID_ModValList[controlNumber] == -1
             || controlPage_ID_ModValList[controlNumber] == -256)    ) //TODO : Check why -256 ?????????

        // Prints a continuous value
        gfx_RectangleFilled( XX * (j-1) + MAX_X/32 ,
                            YY + MAX_Y/10,
                            XX * (j-1) + MAX_X/32 + 34,
                            YY + MAX_Y/10 + 14,
                            BLACK);
        gfx_MoveTo( XX * (j-1) + MAX_X/32, YY + MAX_Y/10  );

        txt_FGcolour(WHITE);
        txt_Width(1);
        txt_Height(2);

        print( controlPage_RawValues[controlNumber] );

    else
        // Display a modal value
        // Mode DISPLAY_PARAM_VALUE or DISPLAY_CUSTOM
        var *LastListNumb, *LastNumb, *LabelBuffer, CurrentListNumb, *numberOfRecords ;
        var file_suffix[4];
        var file_suffix_Ptr;
        file_suffix_Ptr := str_Ptr(file_suffix);
         str_Copy(file_suffix_Ptr, "");
        if( mode == DISPLAY_PARAM_VALUE)
            LastListNumb := &lastLoadedModalList;
            CurrentListNumb := controlPage_ID_ModValList[controlNumber];
            LastNumb := &lastNumbModal;
            LabelBuffer := modalLabelBuffer;
            str_Copy(file_suffix_Ptr, "ML_");
            numberOfRecords := &numberOf_ModVal;
        endif
        if( mode == DISPLAY_CUSTOM )
            // Effect Type Control Page customization
            if( last_displayed_screenType == CUSTOM_EFFECT_TYPE_CONTROL_PAGE )
                LastListNumb := &lastLoadedEffectParametersList;
                CurrentListNumb := CurrentControlPage_EffectTypeID + 2;
                LastNumb := &lastNumbParam;
                LabelBuffer := paramLabelBuffer;
                str_Copy(file_suffix_Ptr, "ET");
                numberOfRecords := &numberOf_Param;
            endif
            // QuickAccess Control Page customization
            if( last_displayed_screenType == CUSTOM_QUICKACCESS_CONTROL_PAGE )
                // Parameter customization
                LastListNumb := &lastLoadedEffectParametersList;
                CurrentListNumb := controlPage_Effect_Type_ID[controlNumber] + 2;
                LastNumb := &lastNumbParam;
                LabelBuffer := paramLabelBuffer;
                str_Copy(file_suffix_Ptr, "ET");
                numberOfRecords := &numberOf_Param;
            endif
        endif

        if( *LastListNumb != CurrentListNumb && last_displayed_screenType != CUSTOM_QUICKACCESS_CONTROL_PAGE_EFFECTBLOCK)
            if( *LastNumb > 0)
                for(k := *LastNumb -1; k >= 0 ; k--)
                    res := mem_Free( LabelBuffer[k] );
                    if ( res == 0  )
                        gfx_MoveTo(0,60);
                        to(TEXT); print( "MEMORY DE-ALLOC ERROR at n°", k, "\n" );
                    endif
                next
            endif

#ifdef DEBUG2
            startTime := sys_T();
            gfx_MoveTo(0,10);
            print("LOADING  = ", sys_T(), "\n");
            gfx_MoveTo(0,20);
            print( "LastListNumb = ", LastListNumb, "\n" );
            gfx_MoveTo(0,30);
            print( "CurrentListNumb = ", CurrentListNumb, "\n" );
            gfx_MoveTo(0,40);
            print( "LastNumb = ", LastNumb, "\n" );
            pause(10000);
#endif
            filePtr := str_Ptr(fileName);
            str_Copy(filePtr, "");
            to(fileName); print( [STR]file_suffix, CurrentListNumb, ".txt\0");

        //to(TEXT);
        //print([STR]fileName, "\n");
        //print( "Length =", str_Length(filePtr), "\n");

            FP2 := file_Open(filePtr, 'r');
            if( file_Error() > 0)
                to(TEXT);print("File ", [STR]fileName,"  not found\n", "File ERROR = ", file_Error() );
                pause(500);
                //continue;
            endif

            p := str_Ptr(tempoSTR);
            str_Copy( p, "");
            // Read number of values
            file_GetS(tempoSTR, 99, FP2);
            p := str_Ptr( tempoSTR );
            str_GetW( &p, numberOfRecords );
            //to(TEXT); print("FILENAME = ", [STR] fileName, " numberOfRecords = ", *numberOfRecords, "\n");
            //pause(3000);

            // TEMPORARY REMOVED
            //
            //if( controlPage_RawValues[controlNumber] < 0 || controlPage_RawValues[controlNumber] >= numberOf_ModVal )
            //    to(TEXT);print("ERROR item > numberOf_ModVal ", controlPage_RawValues[controlNumber], numberOf_ModVal);
            //    pause(5000);
            //   // continue;
            //endif


//to(TEXT); print("numberOf_ModVal ", *numberOfRecords, "\n");
            for(k := 0; k < *numberOfRecords; k++)
                p := str_Ptr( tempoSTR2 );
                str_Copy(p, "");
                res := file_GetS(tempoSTR2, 99, FP2);
//to(TEXT); print("Line ",k, " read = ", [STR] tempoSTR2, "\n");
                if( mode == DISPLAY_CUSTOM)
                   str_GetW(&p,&paramIDBuffer[k]);
                endif
                length := str_Length( p );
//to(TEXT); print("Length of line ", k, " = ", length, "\n");
                if( length > LABEL_MAX_LENGTH-1)
                    length := LABEL_MAX_LENGTH-1;
                endif
                LabelBuffer[k] := mem_Alloc( length +1 );
                if( LabelBuffer[k] == 0 )
                     to(TEXT); print(" Memory ALLOC error for label n° ", k );  pause(500);
                endif
                //p := str_Ptr( tempoSTR2 );
                p2 := str_Ptr( LabelBuffer[k] );
                //str_Copy(p2, "");
                copy_nstr(length, &p, p2); //str_Copy(p2, p);
                //to(TEXT); print("Value stored in label[", k, "] = ", [STR] LabelBuffer[k], "\n");
                //pause(1000);
                if( file_Error() == FE_EOF )
                    to(TEXT); print("File", [STR]fileName,"  not closed\n", "File ERROR = ", file_Error() );  pause(500);
                    break;
                endif
            next

            res := file_Close(FP2);
            if( res == 0)
                to(TEXT); print("File", [STR]fileName,"  not closed\n", "File ERROR = ", file_Error() );  pause(500);
            endif
            *LastListNumb := CurrentListNumb;
            *LastNumb := *numberOfRecords;

#ifdef DEBUG5
            txt_Width(1);
            txt_Height(1);
            txt_FGcolour(WHITE);
            to(TEXT);
            gfx_MoveTo(0,50);
            print( "lastLoadedModalList = ", *LastListNumb, "\n" );
            gfx_MoveTo(0,60);
            print( "lastNumbModal = ", *LastNumb, "\n" );
#endif
        endif

        if( i == 5)
            YY := ( (MAX_Y+1) / 6) * i + ((MAX_Y+1) / 24) -5;
        endif

        gfx_RectangleFilled( XX * (j-1) + MAX_X/ 92,
                            YY + MAX_Y/10 ,
                            XX * (j-1) + MAX_X/9 + 5,
                            YY + MAX_Y/10 + 15,
                            BLACK);

        gfx_MoveTo( XX * (j-1) + MAX_X/92, YY + MAX_Y/10  );
        txt_Width(1);
        txt_Height(2);
        txt_FGcolour(WHITE);

        // Pour les boutons 127 corrspond à 1 (dans une liste)
        if ( controlNumber > 31 && controlNumber < 40 && controlPage_RawValues[controlNumber] > 0)
            controlPage_RawValues[controlNumber] := 1;
        endif

        if( mode == DISPLAY_PARAM_VALUE)
            to(TEXT); print( [STR] modalLabelBuffer[ controlPage_RawValues[controlNumber] ] );
        endif

#ifdef DEBUG5
            to(TEXT);
            gfx_MoveTo(0,70);
            print( "mode = ", mode, "\n" );
            //gfx_MoveTo(0,60);
            //print( "lastNumbModal = ", *LastNumb, "\n" );
#endif

        if( mode == DISPLAY_CUSTOM)
            if( last_displayed_screenType != CUSTOM_QUICKACCESS_CONTROL_PAGE_EFFECTBLOCK )
                //DISPLAY THE LABEL OF THE PARAMETER IN THE RIGHT LOCATION ON THE SCREEN
                for(k := 0; k < lastNumbParam; k++)
                    //to(TEXT); print("k = ", k, " paramLabelBuffer", [STR] paramLabelBuffer[k], "\n");
                    if( paramIDBuffer[k] == controlPage_MIDIValues[controlNumber] )
                        p := str_Ptr( paramLabelBuffer[k]  );
                        p2 := str_Ptr( controlPage_Parameter_Labels[controlNumber]  );
                        //str_Copy(p2, "");
                        length := str_Length( p );
                        copy_nstr(length, &p, p2);// str_Copy(p2, p);
                                  //to(TEXT); print("k = ", k, " controlNumber = ", controlNumber, " paramLabelBuffer", [STR] paramLabelBuffer[k], " controlPage_Parameter_Labels", [STR] controlPage_Parameter_Labels[controlNumber], "\n");
                        break;
                    endif
                next
                to(TEXT); print( [STR] controlPage_Parameter_Labels[ controlNumber ] );
            else
                txt_FGcolour( YELLOW );  //(DARKGRAY);
                txt_BGcolour( DARKRED );
                txt_FontID( FONT1 );
                txt_Width( 1 );
                txt_Height( 1 );
                txt_Bold( ON );
                gfx_MoveTo( XX * (j-1) + MAX_X/28  ,    YY +1  );
                gfx_RectangleFilled( XX * (j-1) + MAX_X/ 28,
                    YY + 1,
                    XX * (j-1) + MAX_X/9 + 5,
                    YY + 15,
                    BLACK);
                putstr( EffectBlock_Label[ controlPage_MIDIValues[controlNumber] ] );
            endif
        endif
    endif
    return;
endfunc





